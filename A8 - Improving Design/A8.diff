diff --git a/A8 - Improving Design/Description/SE1S03-A8-Description.pdf b/A8 - Improving Design/Description/SE1S03-A8-Description.pdf
new file mode 100644
index 0000000..e1ab4f0
--- /dev/null
+++ b/A8 - Improving Design/Description/SE1S03-A8-Description.pdf	
@@ -0,0 +1,66 @@
+‫دانشکده مهندسی برق و کامپیوتر‬
+
+‫مهندسی نرم‌افزار ‪۱‬‬
+
+‫مدرس‪ :‬رامتین خسروی‬
+‫بهار ‪۱۴۰۳‬‬
+
+                               ‫تکلیف هشت‬
+
+                               ‫بررسی و بهبود کیفیت طراحی‬
+
+‫در چند تکلیف اخیر‪ ،‬ویژگ ‌یهای مختلفی را به سامانه معاملات اضافه کرده‌اید‪ .‬طی این تکامل تدریجی طبیعی‬
+‫است در کد سامانه موقعی ‌تهایی برای بهبود طراحی به چشم بیایند‪ .‬این موقعی ‌تها می‌توانند ناشی از‬
+‫بدهی فنی (عامدانه یا سهوی) باشند یا این که به خاطر فهم تدریجی صورت مسئله ایجاد شده باشند‪ .‬به‬
+‫عبارت دیگر شاید اگر از روز اول روی کل منطق دامنه تسلط داشتید طور دیگری طراحی م ‌یکردید‪ .‬هدف این‬
+
+         ‫تکلیف این است که این موقعیت‌ها را شناسایی کنید و را ‌هح ‌لهایی برای بهبود طراحی پیشنهاد کنید‪.‬‬
+
+                               ‫مراحل انجام تکلیف‬
+
+                                                                   ‫گام ‪ .۱‬شناسایی بوهای کد‬
+
+‫در این گام کدی که نوشت ‌هاید را برای یافتن بوهای بد کد بازبینی کنید و موارد پیدا شده را در پاسخ کتبی‬
+‫تکلیف فهرست کنید‪ .‬به عنوان مرجع‪ ،‬می‌توانید بوهای فهرست شده در‬
+‫‪ https://refactoring.guru/refactoring/smells‬را مبنا قرار دهید‪ .‬در پاسخ این قسمت م ‌یتوانید مواردی‬
+
+                ‫که در کامیت‌های حین انجام تکلیف قبل وجود داشته و آن را رفع کرد ‌هاید را هم فهرست کنید‪.‬‬
+
+                                                                         ‫گام ‪ .۲‬اِعمال بازآرایی‬
+
+‫در این گام برای رفع بوهای پیدا شده اقدام کنید و با اعمال قواعد بازآرایی کیفیت کد را افزایش دهید‪ .‬به‬
+‫عنوان مرجع قواعد بازآرایی م ‌یتوانید ‪ https://refactoring.guru/refactoring/techniques‬را مبنا قرار‬
+
+                                               ‫دهید‪ .‬اعمال هر یک از قواعد را در یک کامیت جداگانه انجام دهید‪.‬‬
+                                                         ‫گام ‪ .۳‬موقعی ‌تهای بهبود طراحی‬
+
+‫فراتر از بازآرایی‌های ساده‪ ،‬ممکن است در طرح فعلی فرصت‌هایی برای بهبود طراحی از طریق اعمال الگوهای‬
+    ‫طراحی یا ب ‌هکارگیری اصول طراحی شیءگرا (مثل ‪ )dependency inversion‬وجود داشته باشد‪ .‬کد خود را‬
+
+ ‫برای یافتن چنین فرصت‌هایی بررسی کنید و تا حد امکان بهبودهای لازمه را ایجاد کنید‪ .‬موقعیت‌های بهبود‬
+  ‫طرح را م ‌یتوانید در کدهای آزمون نیز جستجو کنید‪ .‬دقت کنید که نظیر بهبودی که در کلاس بررسی کردیم‪،‬‬
+ ‫این بهبودها را در قد ‌مهای کوچک انجام دهید که در صورتی که فرصت اتمام آن را نداشتید کد کماکان قابل‬
+
+                                                                                                               ‫اجرا باشد‪.‬‬
+
+                                                  ‫نحوه تحویل‬
+
+‫برای تحویل این تکلیف یک فایل پی‌دی‌اف آپلود کنید‪ .‬این فایل برای گام‌های ‪ ۱‬و ‪ ۲‬شامل یک جدول با‬
+                                                                                               ‫ساختار زیر است‪.‬‬
+
+‫شناسه کامیت بازآرای ‌یشده توضیحات (در صورت نیاز)‬  ‫شناسه کامیت حاوی بوی بد شرح مختصر بوی بد‬
+
+‫برای گام ‪ ،۳‬موقعی ‌تهای بهبود طراحی را به طور مختصر شرح دهید‪(.‬شامل مشکلی که در کد وجود دارد و‬
+  ‫کلیات ایده بهبود‪ ).‬در صورتی که هر یک از مشکلات را رفع کرد ‌هاید شناسه کامیت‌های مرتبط را ذکر کنید‪.‬‬
+                                                               ‫منظور از شناسه کامیت همان ‪ SHA‬کامیت است‪.‬‬
+
+                                                           ‫نحوه ارزیابی‬
+
+                                                   ‫پاسخ‌های شما به این تکلیف از جنبه‌های زیر ارزیابی م ‌یشود‪.‬‬
+                                                                                   ‫● گا ‌مهای ‪ ۱‬و ‪ ۵۰( ۲‬درصد)‬
+
+                                                                           ‫○ تشخیص بوهای بد کد‬
+                                                                    ‫○ رفع آنها توسط قواعد بازآرایی‬
+                                                         ‫● پیشنهاد موقعی ‌تهای بهبود طراحی (‪ ۲۵‬درصد)‬
+                                        ‫● بهبود طراحی مبتنی بر پیشنها ‌دهای بند قبل (‪ ۲۵‬درصد به بالا)‬
+
diff --git a/A8 - Improving Design/Description/doc.txt b/A8 - Improving Design/Description/doc.txt
new file mode 100644
index 0000000..4708767
--- /dev/null
+++ b/A8 - Improving Design/Description/doc.txt	
@@ -0,0 +1 @@
+https://docs.google.com/document/d/1uRnltIfNmKQJCng8PWYFuKm7bWFI7bnRZz9YWHb62Ho/edit#heading=h.3h2yg0nx3b1w
\ No newline at end of file
diff --git a/A8 - Improving Design/HELP.md b/A8 - Improving Design/HELP.md
new file mode 100644
index 0000000..95ddff3
--- /dev/null
+++ b/A8 - Improving Design/HELP.md	
@@ -0,0 +1,7 @@
+### Reference Documentation
+
+For further reference, please consider the following sections:
+
+- [Code Smells](https://en.wikipedia.org/wiki/Code_smell)
+- [Code Smells Guru](https://refactoring.guru/refactoring/smells)
+- [Refactoring Guru](https://refactoring.guru/refactoring/techniques)
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/HELP.md b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/HELP.md
new file mode 100644
index 0000000..46ef614
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/HELP.md
@@ -0,0 +1,15 @@
+# Getting Started
+
+### Reference Documentation
+For further reference, please consider the following sections:
+
+* [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
+* [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/docs/3.2.0/maven-plugin/reference/html/)
+* [Create an OCI image](https://docs.spring.io/spring-boot/docs/3.2.0/maven-plugin/reference/html/#build-image)
+* [Spring for Apache ActiveMQ Artemis](https://docs.spring.io/spring-boot/docs/3.2.0/reference/htmlsingle/index.html#messaging.jms.artemis)
+
+### Guides
+The following guides illustrate how to use some features concretely:
+
+* [Messaging with JMS](https://spring.io/guides/gs/messaging-jms/)
+
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/mvnw b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/mvnw
new file mode 100644
index 0000000..66df285
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/mvnw
@@ -0,0 +1,308 @@
+#!/bin/sh
+# ----------------------------------------------------------------------------
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#    https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+# ----------------------------------------------------------------------------
+
+# ----------------------------------------------------------------------------
+# Apache Maven Wrapper startup batch script, version 3.2.0
+#
+# Required ENV vars:
+# ------------------
+#   JAVA_HOME - location of a JDK home dir
+#
+# Optional ENV vars
+# -----------------
+#   MAVEN_OPTS - parameters passed to the Java VM when running Maven
+#     e.g. to debug Maven itself, use
+#       set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000
+#   MAVEN_SKIP_RC - flag to disable loading of mavenrc files
+# ----------------------------------------------------------------------------
+
+if [ -z "$MAVEN_SKIP_RC" ] ; then
+
+  if [ -f /usr/local/etc/mavenrc ] ; then
+    . /usr/local/etc/mavenrc
+  fi
+
+  if [ -f /etc/mavenrc ] ; then
+    . /etc/mavenrc
+  fi
+
+  if [ -f "$HOME/.mavenrc" ] ; then
+    . "$HOME/.mavenrc"
+  fi
+
+fi
+
+# OS specific support.  $var _must_ be set to either true or false.
+cygwin=false;
+darwin=false;
+mingw=false
+case "$(uname)" in
+  CYGWIN*) cygwin=true ;;
+  MINGW*) mingw=true;;
+  Darwin*) darwin=true
+    # Use /usr/libexec/java_home if available, otherwise fall back to /Library/Java/Home
+    # See https://developer.apple.com/library/mac/qa/qa1170/_index.html
+    if [ -z "$JAVA_HOME" ]; then
+      if [ -x "/usr/libexec/java_home" ]; then
+        JAVA_HOME="$(/usr/libexec/java_home)"; export JAVA_HOME
+      else
+        JAVA_HOME="/Library/Java/Home"; export JAVA_HOME
+      fi
+    fi
+    ;;
+esac
+
+if [ -z "$JAVA_HOME" ] ; then
+  if [ -r /etc/gentoo-release ] ; then
+    JAVA_HOME=$(java-config --jre-home)
+  fi
+fi
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched
+if $cygwin ; then
+  [ -n "$JAVA_HOME" ] &&
+    JAVA_HOME=$(cygpath --unix "$JAVA_HOME")
+  [ -n "$CLASSPATH" ] &&
+    CLASSPATH=$(cygpath --path --unix "$CLASSPATH")
+fi
+
+# For Mingw, ensure paths are in UNIX format before anything is touched
+if $mingw ; then
+  [ -n "$JAVA_HOME" ] && [ -d "$JAVA_HOME" ] &&
+    JAVA_HOME="$(cd "$JAVA_HOME" || (echo "cannot cd into $JAVA_HOME."; exit 1); pwd)"
+fi
+
+if [ -z "$JAVA_HOME" ]; then
+  javaExecutable="$(which javac)"
+  if [ -n "$javaExecutable" ] && ! [ "$(expr "\"$javaExecutable\"" : '\([^ ]*\)')" = "no" ]; then
+    # readlink(1) is not available as standard on Solaris 10.
+    readLink=$(which readlink)
+    if [ ! "$(expr "$readLink" : '\([^ ]*\)')" = "no" ]; then
+      if $darwin ; then
+        javaHome="$(dirname "\"$javaExecutable\"")"
+        javaExecutable="$(cd "\"$javaHome\"" && pwd -P)/javac"
+      else
+        javaExecutable="$(readlink -f "\"$javaExecutable\"")"
+      fi
+      javaHome="$(dirname "\"$javaExecutable\"")"
+      javaHome=$(expr "$javaHome" : '\(.*\)/bin')
+      JAVA_HOME="$javaHome"
+      export JAVA_HOME
+    fi
+  fi
+fi
+
+if [ -z "$JAVACMD" ] ; then
+  if [ -n "$JAVA_HOME"  ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+      # IBM's JDK on AIX uses strange locations for the executables
+      JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+      JAVACMD="$JAVA_HOME/bin/java"
+    fi
+  else
+    JAVACMD="$(\unset -f command 2>/dev/null; \command -v java)"
+  fi
+fi
+
+if [ ! -x "$JAVACMD" ] ; then
+  echo "Error: JAVA_HOME is not defined correctly." >&2
+  echo "  We cannot execute $JAVACMD" >&2
+  exit 1
+fi
+
+if [ -z "$JAVA_HOME" ] ; then
+  echo "Warning: JAVA_HOME environment variable is not set."
+fi
+
+# traverses directory structure from process work directory to filesystem root
+# first directory with .mvn subdirectory is considered project base directory
+find_maven_basedir() {
+  if [ -z "$1" ]
+  then
+    echo "Path not specified to find_maven_basedir"
+    return 1
+  fi
+
+  basedir="$1"
+  wdir="$1"
+  while [ "$wdir" != '/' ] ; do
+    if [ -d "$wdir"/.mvn ] ; then
+      basedir=$wdir
+      break
+    fi
+    # workaround for JBEAP-8937 (on Solaris 10/Sparc)
+    if [ -d "${wdir}" ]; then
+      wdir=$(cd "$wdir/.." || exit 1; pwd)
+    fi
+    # end of workaround
+  done
+  printf '%s' "$(cd "$basedir" || exit 1; pwd)"
+}
+
+# concatenates all lines of a file
+concat_lines() {
+  if [ -f "$1" ]; then
+    # Remove \r in case we run on Windows within Git Bash
+    # and check out the repository with auto CRLF management
+    # enabled. Otherwise, we may read lines that are delimited with
+    # \r\n and produce $'-Xarg\r' rather than -Xarg due to word
+    # splitting rules.
+    tr -s '\r\n' ' ' < "$1"
+  fi
+}
+
+log() {
+  if [ "$MVNW_VERBOSE" = true ]; then
+    printf '%s\n' "$1"
+  fi
+}
+
+BASE_DIR=$(find_maven_basedir "$(dirname "$0")")
+if [ -z "$BASE_DIR" ]; then
+  exit 1;
+fi
+
+MAVEN_PROJECTBASEDIR=${MAVEN_BASEDIR:-"$BASE_DIR"}; export MAVEN_PROJECTBASEDIR
+log "$MAVEN_PROJECTBASEDIR"
+
+##########################################################################################
+# Extension to allow automatically downloading the maven-wrapper.jar from Maven-central
+# This allows using the maven wrapper in projects that prohibit checking in binary data.
+##########################################################################################
+wrapperJarPath="$MAVEN_PROJECTBASEDIR/.mvn/wrapper/maven-wrapper.jar"
+if [ -r "$wrapperJarPath" ]; then
+    log "Found $wrapperJarPath"
+else
+    log "Couldn't find $wrapperJarPath, downloading it ..."
+
+    if [ -n "$MVNW_REPOURL" ]; then
+      wrapperUrl="$MVNW_REPOURL/org/apache/maven/wrapper/maven-wrapper/3.2.0/maven-wrapper-3.2.0.jar"
+    else
+      wrapperUrl="https://repo.maven.apache.org/maven2/org/apache/maven/wrapper/maven-wrapper/3.2.0/maven-wrapper-3.2.0.jar"
+    fi
+    while IFS="=" read -r key value; do
+      # Remove '\r' from value to allow usage on windows as IFS does not consider '\r' as a separator ( considers space, tab, new line ('\n'), and custom '=' )
+      safeValue=$(echo "$value" | tr -d '\r')
+      case "$key" in (wrapperUrl) wrapperUrl="$safeValue"; break ;;
+      esac
+    done < "$MAVEN_PROJECTBASEDIR/.mvn/wrapper/maven-wrapper.properties"
+    log "Downloading from: $wrapperUrl"
+
+    if $cygwin; then
+      wrapperJarPath=$(cygpath --path --windows "$wrapperJarPath")
+    fi
+
+    if command -v wget > /dev/null; then
+        log "Found wget ... using wget"
+        [ "$MVNW_VERBOSE" = true ] && QUIET="" || QUIET="--quiet"
+        if [ -z "$MVNW_USERNAME" ] || [ -z "$MVNW_PASSWORD" ]; then
+            wget $QUIET "$wrapperUrl" -O "$wrapperJarPath" || rm -f "$wrapperJarPath"
+        else
+            wget $QUIET --http-user="$MVNW_USERNAME" --http-password="$MVNW_PASSWORD" "$wrapperUrl" -O "$wrapperJarPath" || rm -f "$wrapperJarPath"
+        fi
+    elif command -v curl > /dev/null; then
+        log "Found curl ... using curl"
+        [ "$MVNW_VERBOSE" = true ] && QUIET="" || QUIET="--silent"
+        if [ -z "$MVNW_USERNAME" ] || [ -z "$MVNW_PASSWORD" ]; then
+            curl $QUIET -o "$wrapperJarPath" "$wrapperUrl" -f -L || rm -f "$wrapperJarPath"
+        else
+            curl $QUIET --user "$MVNW_USERNAME:$MVNW_PASSWORD" -o "$wrapperJarPath" "$wrapperUrl" -f -L || rm -f "$wrapperJarPath"
+        fi
+    else
+        log "Falling back to using Java to download"
+        javaSource="$MAVEN_PROJECTBASEDIR/.mvn/wrapper/MavenWrapperDownloader.java"
+        javaClass="$MAVEN_PROJECTBASEDIR/.mvn/wrapper/MavenWrapperDownloader.class"
+        # For Cygwin, switch paths to Windows format before running javac
+        if $cygwin; then
+          javaSource=$(cygpath --path --windows "$javaSource")
+          javaClass=$(cygpath --path --windows "$javaClass")
+        fi
+        if [ -e "$javaSource" ]; then
+            if [ ! -e "$javaClass" ]; then
+                log " - Compiling MavenWrapperDownloader.java ..."
+                ("$JAVA_HOME/bin/javac" "$javaSource")
+            fi
+            if [ -e "$javaClass" ]; then
+                log " - Running MavenWrapperDownloader.java ..."
+                ("$JAVA_HOME/bin/java" -cp .mvn/wrapper MavenWrapperDownloader "$wrapperUrl" "$wrapperJarPath") || rm -f "$wrapperJarPath"
+            fi
+        fi
+    fi
+fi
+##########################################################################################
+# End of extension
+##########################################################################################
+
+# If specified, validate the SHA-256 sum of the Maven wrapper jar file
+wrapperSha256Sum=""
+while IFS="=" read -r key value; do
+  case "$key" in (wrapperSha256Sum) wrapperSha256Sum=$value; break ;;
+  esac
+done < "$MAVEN_PROJECTBASEDIR/.mvn/wrapper/maven-wrapper.properties"
+if [ -n "$wrapperSha256Sum" ]; then
+  wrapperSha256Result=false
+  if command -v sha256sum > /dev/null; then
+    if echo "$wrapperSha256Sum  $wrapperJarPath" | sha256sum -c > /dev/null 2>&1; then
+      wrapperSha256Result=true
+    fi
+  elif command -v shasum > /dev/null; then
+    if echo "$wrapperSha256Sum  $wrapperJarPath" | shasum -a 256 -c > /dev/null 2>&1; then
+      wrapperSha256Result=true
+    fi
+  else
+    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available."
+    echo "Please install either command, or disable validation by removing 'wrapperSha256Sum' from your maven-wrapper.properties."
+    exit 1
+  fi
+  if [ $wrapperSha256Result = false ]; then
+    echo "Error: Failed to validate Maven wrapper SHA-256, your Maven wrapper might be compromised." >&2
+    echo "Investigate or delete $wrapperJarPath to attempt a clean download." >&2
+    echo "If you updated your Maven version, you need to update the specified wrapperSha256Sum property." >&2
+    exit 1
+  fi
+fi
+
+MAVEN_OPTS="$(concat_lines "$MAVEN_PROJECTBASEDIR/.mvn/jvm.config") $MAVEN_OPTS"
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin; then
+  [ -n "$JAVA_HOME" ] &&
+    JAVA_HOME=$(cygpath --path --windows "$JAVA_HOME")
+  [ -n "$CLASSPATH" ] &&
+    CLASSPATH=$(cygpath --path --windows "$CLASSPATH")
+  [ -n "$MAVEN_PROJECTBASEDIR" ] &&
+    MAVEN_PROJECTBASEDIR=$(cygpath --path --windows "$MAVEN_PROJECTBASEDIR")
+fi
+
+# Provide a "standardized" way to retrieve the CLI args that will
+# work with both Windows and non-Windows executions.
+MAVEN_CMD_LINE_ARGS="$MAVEN_CONFIG $*"
+export MAVEN_CMD_LINE_ARGS
+
+WRAPPER_LAUNCHER=org.apache.maven.wrapper.MavenWrapperMain
+
+# shellcheck disable=SC2086 # safe args
+exec "$JAVACMD" \
+  $MAVEN_OPTS \
+  $MAVEN_DEBUG_OPTS \
+  -classpath "$MAVEN_PROJECTBASEDIR/.mvn/wrapper/maven-wrapper.jar" \
+  "-Dmaven.multiModuleProjectDirectory=${MAVEN_PROJECTBASEDIR}" \
+  ${WRAPPER_LAUNCHER} $MAVEN_CONFIG "$@"
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/mvnw.cmd b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/mvnw.cmd
new file mode 100644
index 0000000..95ba6f5
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/mvnw.cmd
@@ -0,0 +1,205 @@
+@REM ----------------------------------------------------------------------------
+@REM Licensed to the Apache Software Foundation (ASF) under one
+@REM or more contributor license agreements.  See the NOTICE file
+@REM distributed with this work for additional information
+@REM regarding copyright ownership.  The ASF licenses this file
+@REM to you under the Apache License, Version 2.0 (the
+@REM "License"); you may not use this file except in compliance
+@REM with the License.  You may obtain a copy of the License at
+@REM
+@REM    https://www.apache.org/licenses/LICENSE-2.0
+@REM
+@REM Unless required by applicable law or agreed to in writing,
+@REM software distributed under the License is distributed on an
+@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+@REM KIND, either express or implied.  See the License for the
+@REM specific language governing permissions and limitations
+@REM under the License.
+@REM ----------------------------------------------------------------------------
+
+@REM ----------------------------------------------------------------------------
+@REM Apache Maven Wrapper startup batch script, version 3.2.0
+@REM
+@REM Required ENV vars:
+@REM JAVA_HOME - location of a JDK home dir
+@REM
+@REM Optional ENV vars
+@REM MAVEN_BATCH_ECHO - set to 'on' to enable the echoing of the batch commands
+@REM MAVEN_BATCH_PAUSE - set to 'on' to wait for a keystroke before ending
+@REM MAVEN_OPTS - parameters passed to the Java VM when running Maven
+@REM     e.g. to debug Maven itself, use
+@REM set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000
+@REM MAVEN_SKIP_RC - flag to disable loading of mavenrc files
+@REM ----------------------------------------------------------------------------
+
+@REM Begin all REM lines with '@' in case MAVEN_BATCH_ECHO is 'on'
+@echo off
+@REM set title of command window
+title %0
+@REM enable echoing by setting MAVEN_BATCH_ECHO to 'on'
+@if "%MAVEN_BATCH_ECHO%" == "on"  echo %MAVEN_BATCH_ECHO%
+
+@REM set %HOME% to equivalent of $HOME
+if "%HOME%" == "" (set "HOME=%HOMEDRIVE%%HOMEPATH%")
+
+@REM Execute a user defined script before this one
+if not "%MAVEN_SKIP_RC%" == "" goto skipRcPre
+@REM check for pre script, once with legacy .bat ending and once with .cmd ending
+if exist "%USERPROFILE%\mavenrc_pre.bat" call "%USERPROFILE%\mavenrc_pre.bat" %*
+if exist "%USERPROFILE%\mavenrc_pre.cmd" call "%USERPROFILE%\mavenrc_pre.cmd" %*
+:skipRcPre
+
+@setlocal
+
+set ERROR_CODE=0
+
+@REM To isolate internal variables from possible post scripts, we use another setlocal
+@setlocal
+
+@REM ==== START VALIDATION ====
+if not "%JAVA_HOME%" == "" goto OkJHome
+
+echo.
+echo Error: JAVA_HOME not found in your environment. >&2
+echo Please set the JAVA_HOME variable in your environment to match the >&2
+echo location of your Java installation. >&2
+echo.
+goto error
+
+:OkJHome
+if exist "%JAVA_HOME%\bin\java.exe" goto init
+
+echo.
+echo Error: JAVA_HOME is set to an invalid directory. >&2
+echo JAVA_HOME = "%JAVA_HOME%" >&2
+echo Please set the JAVA_HOME variable in your environment to match the >&2
+echo location of your Java installation. >&2
+echo.
+goto error
+
+@REM ==== END VALIDATION ====
+
+:init
+
+@REM Find the project base dir, i.e. the directory that contains the folder ".mvn".
+@REM Fallback to current working directory if not found.
+
+set MAVEN_PROJECTBASEDIR=%MAVEN_BASEDIR%
+IF NOT "%MAVEN_PROJECTBASEDIR%"=="" goto endDetectBaseDir
+
+set EXEC_DIR=%CD%
+set WDIR=%EXEC_DIR%
+:findBaseDir
+IF EXIST "%WDIR%"\.mvn goto baseDirFound
+cd ..
+IF "%WDIR%"=="%CD%" goto baseDirNotFound
+set WDIR=%CD%
+goto findBaseDir
+
+:baseDirFound
+set MAVEN_PROJECTBASEDIR=%WDIR%
+cd "%EXEC_DIR%"
+goto endDetectBaseDir
+
+:baseDirNotFound
+set MAVEN_PROJECTBASEDIR=%EXEC_DIR%
+cd "%EXEC_DIR%"
+
+:endDetectBaseDir
+
+IF NOT EXIST "%MAVEN_PROJECTBASEDIR%\.mvn\jvm.config" goto endReadAdditionalConfig
+
+@setlocal EnableExtensions EnableDelayedExpansion
+for /F "usebackq delims=" %%a in ("%MAVEN_PROJECTBASEDIR%\.mvn\jvm.config") do set JVM_CONFIG_MAVEN_PROPS=!JVM_CONFIG_MAVEN_PROPS! %%a
+@endlocal & set JVM_CONFIG_MAVEN_PROPS=%JVM_CONFIG_MAVEN_PROPS%
+
+:endReadAdditionalConfig
+
+SET MAVEN_JAVA_EXE="%JAVA_HOME%\bin\java.exe"
+set WRAPPER_JAR="%MAVEN_PROJECTBASEDIR%\.mvn\wrapper\maven-wrapper.jar"
+set WRAPPER_LAUNCHER=org.apache.maven.wrapper.MavenWrapperMain
+
+set WRAPPER_URL="https://repo.maven.apache.org/maven2/org/apache/maven/wrapper/maven-wrapper/3.2.0/maven-wrapper-3.2.0.jar"
+
+FOR /F "usebackq tokens=1,2 delims==" %%A IN ("%MAVEN_PROJECTBASEDIR%\.mvn\wrapper\maven-wrapper.properties") DO (
+    IF "%%A"=="wrapperUrl" SET WRAPPER_URL=%%B
+)
+
+@REM Extension to allow automatically downloading the maven-wrapper.jar from Maven-central
+@REM This allows using the maven wrapper in projects that prohibit checking in binary data.
+if exist %WRAPPER_JAR% (
+    if "%MVNW_VERBOSE%" == "true" (
+        echo Found %WRAPPER_JAR%
+    )
+) else (
+    if not "%MVNW_REPOURL%" == "" (
+        SET WRAPPER_URL="%MVNW_REPOURL%/org/apache/maven/wrapper/maven-wrapper/3.2.0/maven-wrapper-3.2.0.jar"
+    )
+    if "%MVNW_VERBOSE%" == "true" (
+        echo Couldn't find %WRAPPER_JAR%, downloading it ...
+        echo Downloading from: %WRAPPER_URL%
+    )
+
+    powershell -Command "&{"^
+		"$webclient = new-object System.Net.WebClient;"^
+		"if (-not ([string]::IsNullOrEmpty('%MVNW_USERNAME%') -and [string]::IsNullOrEmpty('%MVNW_PASSWORD%'))) {"^
+		"$webclient.Credentials = new-object System.Net.NetworkCredential('%MVNW_USERNAME%', '%MVNW_PASSWORD%');"^
+		"}"^
+		"[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; $webclient.DownloadFile('%WRAPPER_URL%', '%WRAPPER_JAR%')"^
+		"}"
+    if "%MVNW_VERBOSE%" == "true" (
+        echo Finished downloading %WRAPPER_JAR%
+    )
+)
+@REM End of extension
+
+@REM If specified, validate the SHA-256 sum of the Maven wrapper jar file
+SET WRAPPER_SHA_256_SUM=""
+FOR /F "usebackq tokens=1,2 delims==" %%A IN ("%MAVEN_PROJECTBASEDIR%\.mvn\wrapper\maven-wrapper.properties") DO (
+    IF "%%A"=="wrapperSha256Sum" SET WRAPPER_SHA_256_SUM=%%B
+)
+IF NOT %WRAPPER_SHA_256_SUM%=="" (
+    powershell -Command "&{"^
+       "$hash = (Get-FileHash \"%WRAPPER_JAR%\" -Algorithm SHA256).Hash.ToLower();"^
+       "If('%WRAPPER_SHA_256_SUM%' -ne $hash){"^
+       "  Write-Output 'Error: Failed to validate Maven wrapper SHA-256, your Maven wrapper might be compromised.';"^
+       "  Write-Output 'Investigate or delete %WRAPPER_JAR% to attempt a clean download.';"^
+       "  Write-Output 'If you updated your Maven version, you need to update the specified wrapperSha256Sum property.';"^
+       "  exit 1;"^
+       "}"^
+       "}"
+    if ERRORLEVEL 1 goto error
+)
+
+@REM Provide a "standardized" way to retrieve the CLI args that will
+@REM work with both Windows and non-Windows executions.
+set MAVEN_CMD_LINE_ARGS=%*
+
+%MAVEN_JAVA_EXE% ^
+  %JVM_CONFIG_MAVEN_PROPS% ^
+  %MAVEN_OPTS% ^
+  %MAVEN_DEBUG_OPTS% ^
+  -classpath %WRAPPER_JAR% ^
+  "-Dmaven.multiModuleProjectDirectory=%MAVEN_PROJECTBASEDIR%" ^
+  %WRAPPER_LAUNCHER% %MAVEN_CONFIG% %*
+if ERRORLEVEL 1 goto error
+goto end
+
+:error
+set ERROR_CODE=1
+
+:end
+@endlocal & set ERROR_CODE=%ERROR_CODE%
+
+if not "%MAVEN_SKIP_RC%"=="" goto skipRcPost
+@REM check for post script, once with legacy .bat ending and once with .cmd ending
+if exist "%USERPROFILE%\mavenrc_post.bat" call "%USERPROFILE%\mavenrc_post.bat"
+if exist "%USERPROFILE%\mavenrc_post.cmd" call "%USERPROFILE%\mavenrc_post.cmd"
+:skipRcPost
+
+@REM pause the script if MAVEN_BATCH_PAUSE is set to 'on'
+if "%MAVEN_BATCH_PAUSE%"=="on" pause
+
+if "%MAVEN_TERMINATE_CMD%"=="on" exit %ERROR_CODE%
+
+cmd /C exit /B %ERROR_CODE%
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/pom.xml b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/pom.xml
new file mode 100644
index 0000000..63f5538
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/pom.xml
@@ -0,0 +1,60 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
+	<modelVersion>4.0.0</modelVersion>
+	<parent>
+		<groupId>org.springframework.boot</groupId>
+		<artifactId>spring-boot-starter-parent</artifactId>
+		<version>3.2.0</version>
+		<relativePath/> <!-- lookup parent from repository -->
+	</parent>
+	<groupId>ir.ramtung</groupId>
+	<artifactId>tinyme</artifactId>
+	<version>0.0.1-SNAPSHOT</version>
+	<name>TinyME</name>
+	<description>Base project for Advanced Software Design (ASDF03)</description>
+	<properties>
+		<java.version>17</java.version>
+	</properties>
+	<dependencies>
+		<dependency>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-starter-artemis</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-starter-json</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-starter-test</artifactId>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-configuration-processor</artifactId>
+			<optional>true</optional>
+		</dependency>
+		<dependency>
+			<groupId>org.projectlombok</groupId>
+			<artifactId>lombok</artifactId>
+			<version>1.18.28</version>
+			<scope>compile</scope>
+		</dependency>
+		<dependency>
+			<groupId>com.opencsv</groupId>
+			<artifactId>opencsv</artifactId>
+			<version>5.8</version>
+		</dependency>
+	</dependencies>
+
+	<build>
+		<plugins>
+			<plugin>
+				<groupId>org.springframework.boot</groupId>
+				<artifactId>spring-boot-maven-plugin</artifactId>
+			</plugin>
+		</plugins>
+	</build>
+
+</project>
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/TinyMeApplication.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/TinyMeApplication.java
new file mode 100644
index 0000000..9492c6f
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/TinyMeApplication.java
@@ -0,0 +1,14 @@
+package ir.ramtung.tinyme;
+
+import org.springframework.boot.SpringApplication;
+import org.springframework.boot.autoconfigure.SpringBootApplication;
+import org.springframework.jms.annotation.EnableJms;
+
+@SpringBootApplication
+@EnableJms
+public class TinyMeApplication {
+
+	public static void main(String[] args) {
+		SpringApplication.run(TinyMeApplication.class, args);
+	}
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/Broker.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/Broker.java
new file mode 100644
index 0000000..30b30f0
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/Broker.java
@@ -0,0 +1,33 @@
+package ir.ramtung.tinyme.domain.entity;
+
+import lombok.Builder;
+import lombok.EqualsAndHashCode;
+import lombok.Getter;
+import lombok.ToString;
+
+@ToString
+@EqualsAndHashCode(onlyExplicitlyIncluded = true)
+@Builder
+public class Broker {
+    @Getter
+    @EqualsAndHashCode.Include
+    private long brokerId;
+    @Getter
+    private String name;
+    @Getter
+    private long credit;
+
+    public void increaseCreditBy(long amount) {
+        assert amount >= 0;
+        credit += amount;
+    }
+
+    public void decreaseCreditBy(long amount) {
+        assert amount >= 0;
+        credit -= amount;
+    }
+
+    public boolean hasEnoughCredit(long amount) {
+        return credit >= amount;
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/IcebergOrder.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/IcebergOrder.java
new file mode 100644
index 0000000..e35277f
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/IcebergOrder.java
@@ -0,0 +1,163 @@
+package ir.ramtung.tinyme.domain.entity;
+
+import ir.ramtung.tinyme.messaging.request.EnterOrderRq;
+import lombok.EqualsAndHashCode;
+import lombok.Getter;
+import lombok.ToString;
+import lombok.experimental.SuperBuilder;
+
+import java.time.LocalDateTime;
+
+@Getter
+@EqualsAndHashCode(callSuper = true)
+@ToString(callSuper = true)
+@SuperBuilder
+public class IcebergOrder extends Order {
+    int peakSize;
+    int displayedQuantity;
+
+    public IcebergOrder(long orderId,
+                        Security security,
+                        Side side,
+                        int initialQuantity,
+                        int quantity,
+                        int price,
+                        Broker broker,
+                        Shareholder shareholder,
+                        LocalDateTime entryTime,
+                        int peakSize,
+                        int displayedQuantity,
+                        int minimumExecutionQuantity,
+                        OrderStatus status) {
+        super(orderId, security, side, initialQuantity, quantity, price, broker, shareholder, entryTime, minimumExecutionQuantity, status);
+        this.peakSize = peakSize;
+        this.displayedQuantity = displayedQuantity;
+    }
+
+    public IcebergOrder(long orderId,
+                        Security security,
+                        Side side,
+                        int initialQuantity,
+                        int quantity,
+                        int price,
+                        Broker broker,
+                        Shareholder shareholder,
+                        LocalDateTime entryTime,
+                        int peakSize,
+                        int minimumExecutionQuantity,
+                        OrderStatus status) {
+        this(orderId, security, side, initialQuantity, quantity, price, broker, shareholder, entryTime, peakSize, Math.min(peakSize, quantity), minimumExecutionQuantity, status);
+    }
+
+    public IcebergOrder(long orderId,
+                        Security security,
+                        Side side,
+                        int quantity,
+                        int price,
+                        Broker broker,
+                        Shareholder shareholder,
+                        LocalDateTime entryTime,
+                        int peakSize,
+                        int minimumExecutionQuantity) {
+        this(orderId, security, side, quantity, quantity, price, broker, shareholder, entryTime, peakSize, minimumExecutionQuantity, OrderStatus.NEW);
+    }
+
+    public IcebergOrder(long orderId,
+                        Security security,
+                        Side side,
+                        int quantity,
+                        int price,
+                        Broker broker,
+                        Shareholder shareholder,
+                        int peakSize,
+                        int minimumExecutionQuantity) {
+        super(orderId, security, side, quantity, price, broker, shareholder, minimumExecutionQuantity);
+        this.peakSize = peakSize;
+        this.displayedQuantity = Math.min(peakSize, quantity);
+    }
+
+    public IcebergOrder(long orderId,
+                        Security security,
+                        Side side,
+                        int quantity,
+                        int price,
+                        Broker broker,
+                        Shareholder shareholder,
+                        int peakSize) {
+        super(orderId, security, side, quantity, price, broker, shareholder, 0);
+        this.peakSize = peakSize;
+        this.displayedQuantity = Math.min(peakSize, quantity);
+    }
+
+    @Override
+    public Order snapshot() {
+        return new IcebergOrder(orderId,
+                security,
+                side,
+                initialQuantity,
+                quantity,
+                price,
+                broker,
+                shareholder,
+                entryTime,
+                peakSize,
+                minimumExecutionQuantity,
+                OrderStatus.SNAPSHOT);
+    }
+
+    @Override
+    public Order snapshotWithQuantity(int newQuantity) {
+        return new IcebergOrder(orderId,
+                security,
+                side,
+                initialQuantity,
+                newQuantity,
+                price,
+                broker,
+                shareholder,
+                entryTime,
+                peakSize,
+                minimumExecutionQuantity,
+                OrderStatus.SNAPSHOT);
+    }
+
+    @Override
+    public int getQuantity() {
+        if (status == OrderStatus.NEW)
+            return super.getQuantity();
+        return displayedQuantity;
+    }
+
+    @Override
+    public void decreaseQuantity(int amount) {
+        if (status == OrderStatus.NEW) {
+            super.decreaseQuantity(amount);
+            return;
+        }
+        if (amount > displayedQuantity)
+            throw new IllegalArgumentException();
+        quantity -= amount;
+        displayedQuantity -= amount;
+    }
+
+    public void replenish() {
+        displayedQuantity = Math.min(quantity, peakSize);
+    }
+
+    @Override
+    public boolean minimumExecutionQuantitySatisfied() {
+        displayedQuantity = Math.min(quantity, peakSize);
+        return super.minimumExecutionQuantitySatisfied();
+    }
+
+    @Override
+    public void updateFromRequest(EnterOrderRq updateOrderRq) {
+        super.updateFromRequest(updateOrderRq);
+        if (peakSize < updateOrderRq.getPeakSize()) {
+            displayedQuantity = Math.min(quantity, updateOrderRq.getPeakSize());
+        } else if (peakSize > updateOrderRq.getPeakSize()) {
+            displayedQuantity = Math.min(displayedQuantity, updateOrderRq.getPeakSize());
+        }
+        peakSize = updateOrderRq.getPeakSize();
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/Order.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/Order.java
new file mode 100644
index 0000000..ded0fc8
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/Order.java
@@ -0,0 +1,186 @@
+package ir.ramtung.tinyme.domain.entity;
+
+import ir.ramtung.tinyme.messaging.request.EnterOrderRq;
+import lombok.Builder;
+import lombok.EqualsAndHashCode;
+import lombok.Getter;
+import lombok.ToString;
+import lombok.experimental.SuperBuilder;
+
+import java.time.LocalDateTime;
+
+@SuperBuilder
+@EqualsAndHashCode
+@ToString
+@Getter
+public class Order {
+    protected long orderId;
+    protected Security security;
+    protected Side side;
+    protected int initialQuantity;
+    protected int quantity;
+    protected int price;
+    protected Broker broker;
+    protected Shareholder shareholder;
+    @Builder.Default
+    protected LocalDateTime entryTime = LocalDateTime.now();
+    protected int minimumExecutionQuantity;
+    @Builder.Default
+    protected OrderStatus status = OrderStatus.NEW;
+
+    public Order(long orderId,
+                 Security security,
+                 Side side,
+                 int initialQuantity,
+                 int quantity,
+                 int price,
+                 Broker broker,
+                 Shareholder shareholder,
+                 LocalDateTime entryTime,
+                 int minimumExecutionQuantity,
+                 OrderStatus status) {
+        this.orderId = orderId;
+        this.security = security;
+        this.side = side;
+        this.quantity = quantity;
+        this.initialQuantity = initialQuantity;
+        this.minimumExecutionQuantity = minimumExecutionQuantity;
+        this.price = price;
+        this.entryTime = entryTime;
+        this.broker = broker;
+        this.shareholder = shareholder;
+        this.status = status;
+    }
+
+    public Order(long orderId,
+                 Security security,
+                 Side side,
+                 int quantity,
+                 int price,
+                 Broker broker,
+                 Shareholder shareholder,
+                 LocalDateTime entryTime,
+                 int minimumExecutionQuantity) {
+        this.orderId = orderId;
+        this.security = security;
+        this.side = side;
+        this.quantity = quantity;
+        this.initialQuantity = quantity;
+        this.minimumExecutionQuantity = minimumExecutionQuantity;
+        this.price = price;
+        this.entryTime = entryTime;
+        this.broker = broker;
+        this.shareholder = shareholder;
+        this.status = OrderStatus.NEW;
+    }
+
+
+    public Order(long orderId,
+                 Security security,
+                 Side side,
+                 int quantity,
+                 int price,
+                 Broker broker,
+                 Shareholder shareholder,
+                 int minimumExecutionQuantity) {
+        this(orderId, security, side, quantity, price, broker, shareholder, LocalDateTime.now(), minimumExecutionQuantity);
+    }
+
+    public Order(long orderId,
+                 Security security,
+                 Side side,
+                 int quantity,
+                 int price,
+                 Broker broker,
+                 Shareholder shareholder) {
+        this(orderId, security, side, quantity, price, broker, shareholder, LocalDateTime.now(), 0);
+    }
+
+    public Order snapshot() {
+        return new Order(orderId,
+                security,
+                side,
+                initialQuantity,
+                quantity,
+                price,
+                broker,
+                shareholder,
+                entryTime,
+                minimumExecutionQuantity,
+                OrderStatus.SNAPSHOT);
+    }
+
+    public Order snapshotWithQuantity(int newQuantity) {
+        return new Order(orderId,
+                security,
+                side,
+                initialQuantity,
+                newQuantity,
+                price,
+                broker,
+                shareholder,
+                entryTime,
+                minimumExecutionQuantity,
+                OrderStatus.SNAPSHOT);
+    }
+
+    public boolean matches(Order other) {
+        if (side == Side.BUY)
+            return price >= other.price;
+        else
+            return price <= other.price;
+    }
+
+    public void decreaseQuantity(int amount) {
+        if (amount > quantity)
+            throw new IllegalArgumentException();
+        quantity -= amount;
+    }
+
+    public void makeQuantityZero() {
+        quantity = 0;
+    }
+
+    public boolean queuesBefore(Order order) {
+        if (order.getSide() == Side.BUY) {
+            return price > order.getPrice();
+        } else {
+            return price < order.getPrice();
+        }
+    }
+
+    public boolean minimumExecutionQuantitySatisfied() {
+        if (initialQuantity - quantity < minimumExecutionQuantity)
+            return false;
+        return true;
+    }
+
+    public void markAsQueued() {
+        status = OrderStatus.QUEUED;
+    }
+
+    public void markAsNew() {
+        status = OrderStatus.NEW;
+    }
+
+    public boolean isQuantityIncreased(int newQuantity) {
+        return newQuantity > quantity;
+    }
+
+    public void updateFromRequest(EnterOrderRq updateOrderRq) {
+        if (quantity != updateOrderRq.getQuantity()) {
+            int executedQuantity = initialQuantity - quantity;
+            initialQuantity = updateOrderRq.getQuantity() + executedQuantity;
+        }
+        quantity = updateOrderRq.getQuantity();
+        price = updateOrderRq.getPrice();
+    }
+
+    public long getValue() {
+        return (long) price * quantity;
+    }
+
+    public int getTotalQuantity() {
+        return quantity;
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/OrderBook.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/OrderBook.java
new file mode 100644
index 0000000..37f9a88
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/OrderBook.java
@@ -0,0 +1,91 @@
+package ir.ramtung.tinyme.domain.entity;
+
+import lombok.Getter;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.ListIterator;
+
+@Getter
+public class OrderBook {
+    private final LinkedList<Order> buyQueue;
+    private final LinkedList<Order> sellQueue;
+
+    public OrderBook() {
+        buyQueue = new LinkedList<>();
+        sellQueue = new LinkedList<>();
+    }
+
+    public boolean enqueue(Order order) {
+        List<Order> queue = getQueue(order.getSide());
+        ListIterator<Order> it = queue.listIterator();
+        while (it.hasNext()) {
+            if (order.queuesBefore(it.next())) {
+                it.previous();
+                break;
+            }
+        }
+        it.add(order);
+        order.markAsQueued();
+        return true;
+    }
+
+    private LinkedList<Order> getQueue(Side side) {
+        return side == Side.BUY ? buyQueue : sellQueue;
+    }
+
+    public Order findByOrderId(Side side, long orderId) {
+        var queue = getQueue(side);
+        for (Order order : queue) {
+            if (order.getOrderId() == orderId)
+                return order;
+        }
+        return null;
+    }
+
+    public boolean removeByOrderId(Side side, long orderId) {
+        var queue = getQueue(side);
+        var it = queue.listIterator();
+        while (it.hasNext()) {
+            if (it.next().getOrderId() == orderId) {
+                it.remove();
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public Order matchWithFirst(Order newOrder) {
+        var queue = getQueue(newOrder.getSide().opposite());
+        if (newOrder.matches(queue.getFirst()))
+            return queue.getFirst();
+        else
+            return null;
+    }
+
+    public void putBack(Order order) {
+        LinkedList<Order> queue = getQueue(order.getSide());
+        order.minimumExecutionQuantitySatisfied(); //why?
+        queue.addFirst(order);
+    }
+
+    public void restoreOrder(Order order) {
+        removeByOrderId(order.getSide(), order.getOrderId());
+        putBack(order);
+    }
+
+    public boolean hasOrderOfType(Side side) {
+        return !getQueue(side).isEmpty();
+    }
+
+    public void removeFirst(Side side) {
+        getQueue(side).removeFirst();
+    }
+
+    public int totalSellQuantityByShareholder(Shareholder shareholder) {
+        return sellQueue.stream()
+                .filter(order -> order.getShareholder().equals(shareholder))
+                .mapToInt(Order::getTotalQuantity)
+                .sum();
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/OrderStatus.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/OrderStatus.java
new file mode 100644
index 0000000..db2ad51
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/OrderStatus.java
@@ -0,0 +1,7 @@
+package ir.ramtung.tinyme.domain.entity;
+
+public enum OrderStatus {
+    NEW,
+    QUEUED,
+    SNAPSHOT
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/Security.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/Security.java
new file mode 100644
index 0000000..5fa3b24
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/Security.java
@@ -0,0 +1,91 @@
+package ir.ramtung.tinyme.domain.entity;
+
+import ir.ramtung.tinyme.domain.service.MatchResult;
+import ir.ramtung.tinyme.domain.service.MatchingOutcome;
+import ir.ramtung.tinyme.messaging.exception.InvalidRequestException;
+import ir.ramtung.tinyme.messaging.request.DeleteOrderRq;
+import ir.ramtung.tinyme.messaging.request.EnterOrderRq;
+import ir.ramtung.tinyme.domain.service.Matcher;
+import ir.ramtung.tinyme.messaging.Message;
+import lombok.Builder;
+import lombok.Getter;
+
+import java.util.List;
+
+@Getter
+@Builder
+public class Security {
+    private String isin;
+    @Builder.Default
+    private int tickSize = 1;
+    @Builder.Default
+    private int lotSize = 1;
+    @Builder.Default
+    private OrderBook orderBook = new OrderBook();
+
+    public MatchResult newOrder(EnterOrderRq enterOrderRq, Broker broker, Shareholder shareholder, Matcher matcher) {
+        Order order;
+        if (enterOrderRq.getPeakSize() == 0)
+            order = new Order(enterOrderRq.getOrderId(), this, enterOrderRq.getSide(),
+                    enterOrderRq.getQuantity(), enterOrderRq.getPrice(), broker, shareholder, enterOrderRq.getEntryTime(),
+                    enterOrderRq.getMinimumExecutionQuantity());
+        else
+            order = new IcebergOrder(enterOrderRq.getOrderId(), this, enterOrderRq.getSide(),
+                    enterOrderRq.getQuantity(), enterOrderRq.getPrice(), broker, shareholder,
+                    enterOrderRq.getEntryTime(), enterOrderRq.getPeakSize(), enterOrderRq.getMinimumExecutionQuantity());
+
+        return matcher.execute(order);
+    }
+
+    public void deleteOrder(DeleteOrderRq deleteOrderRq) throws InvalidRequestException {
+        Order order = orderBook.findByOrderId(deleteOrderRq.getSide(), deleteOrderRq.getOrderId());
+        if (order == null)
+            throw new InvalidRequestException(Message.ORDER_ID_NOT_FOUND);
+        if (order.getSide() == Side.BUY)
+            order.getBroker().increaseCreditBy(order.getValue());
+        orderBook.removeByOrderId(deleteOrderRq.getSide(), deleteOrderRq.getOrderId());
+    }
+
+    public MatchResult updateOrder(EnterOrderRq updateOrderRq, Matcher matcher) throws InvalidRequestException {
+        Order order = orderBook.findByOrderId(updateOrderRq.getSide(), updateOrderRq.getOrderId());
+        if (order == null)
+            throw new InvalidRequestException(Message.ORDER_ID_NOT_FOUND);
+        if ((order instanceof IcebergOrder) && updateOrderRq.getPeakSize() == 0)
+            throw new InvalidRequestException(Message.INVALID_PEAK_SIZE);
+        if (!(order instanceof IcebergOrder) && updateOrderRq.getPeakSize() != 0)
+            throw new InvalidRequestException(Message.CANNOT_SPECIFY_PEAK_SIZE_FOR_A_NON_ICEBERG_ORDER);
+
+        if (updateOrderRq.getSide() == Side.SELL &&
+                !order.getShareholder().hasEnoughPositionsOn(this,
+                orderBook.totalSellQuantityByShareholder(order.getShareholder()) - order.getQuantity() + updateOrderRq.getQuantity()))
+            return MatchResult.notEnoughPositions();
+
+        boolean losesPriority = order.isQuantityIncreased(updateOrderRq.getQuantity())
+                || updateOrderRq.getPrice() != order.getPrice()
+                || ((order instanceof IcebergOrder icebergOrder) && (icebergOrder.getPeakSize() < updateOrderRq.getPeakSize()));
+
+        if (updateOrderRq.getSide() == Side.BUY) {
+            order.getBroker().increaseCreditBy(order.getValue());
+        }
+        Order originalOrder = order.snapshot();
+        order.updateFromRequest(updateOrderRq);
+        if (!losesPriority) {
+            if (updateOrderRq.getSide() == Side.BUY) {
+                order.getBroker().decreaseCreditBy(order.getValue());
+            }
+            return MatchResult.executed(null, List.of());
+        }
+        else
+            order.markAsNew();
+
+        orderBook.removeByOrderId(updateOrderRq.getSide(), updateOrderRq.getOrderId());
+        MatchResult matchResult = matcher.execute(order);
+        if (matchResult.outcome() != MatchingOutcome.OK) {
+            orderBook.enqueue(originalOrder);
+            if (updateOrderRq.getSide() == Side.BUY) {
+                originalOrder.getBroker().decreaseCreditBy(originalOrder.getValue());
+            }
+        }
+        return matchResult;
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/Shareholder.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/Shareholder.java
new file mode 100644
index 0000000..0e4edd0
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/Shareholder.java
@@ -0,0 +1,39 @@
+package ir.ramtung.tinyme.domain.entity;
+
+import lombok.Builder;
+import lombok.EqualsAndHashCode;
+import lombok.Getter;
+import lombok.ToString;
+
+import java.util.HashMap;
+import java.util.Map;
+
+@ToString
+@EqualsAndHashCode(onlyExplicitlyIncluded = true)
+@Builder
+public class Shareholder {
+    @Getter
+    @EqualsAndHashCode.Include
+    private long shareholderId;
+    @Getter
+    private String name;
+    @Getter
+    @Builder.Default
+    private Map<Security, Integer> positions = new HashMap<>();
+
+    public void incPosition(Security security, int amount) {
+        assert amount >= 0;
+        positions.put(security, positions.getOrDefault(security, 0) + amount);
+    }
+
+    public void decPosition(Security security, int amount) {
+        assert amount >= 0;
+        int currentPositions = positions.getOrDefault(security, 0);
+        if (currentPositions < amount)
+            throw new IllegalArgumentException("Amount to be decreased is greater than shareholder's current position");
+        positions.put(security, currentPositions - amount);
+    }
+    public boolean hasEnoughPositionsOn(Security security, int position) {
+        return positions.getOrDefault(security, 0) >= position;
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/Side.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/Side.java
new file mode 100644
index 0000000..4d23adb
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/Side.java
@@ -0,0 +1,27 @@
+package ir.ramtung.tinyme.domain.entity;
+
+public enum Side {
+    BUY {
+        @Override
+        public Side opposite() {
+            return SELL;
+        }
+    },
+    SELL {
+        @Override
+        public Side opposite() {
+            return BUY;
+        }
+    };
+
+    public static Side parse(String s) {
+        if (s.equals("BUY"))
+            return BUY;
+        else if (s.equals("SELL"))
+            return SELL;
+        else
+            throw new IllegalArgumentException("Invalid value for order side");
+    }
+
+    public abstract Side opposite();
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/Trade.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/Trade.java
new file mode 100644
index 0000000..88e710a
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/entity/Trade.java
@@ -0,0 +1,50 @@
+package ir.ramtung.tinyme.domain.entity;
+
+import lombok.Builder;
+import lombok.EqualsAndHashCode;
+import lombok.Getter;
+import lombok.ToString;
+
+@Builder
+@Getter
+@EqualsAndHashCode
+@ToString
+public class Trade {
+    Security security;
+    private int price;
+    private int quantity;
+    private Order buy;
+    private Order sell;
+
+    public Trade(Security security, int price, int quantity, Order order1, Order order2) {
+        this.security = security;
+        this.price = price;
+        this.quantity = quantity;
+        Order snapshot1 = order1.snapshot();
+        Order snapshot2 = order2.snapshot();
+        if (order1.getSide() == Side.BUY) {
+            this.buy = snapshot1;
+            this.sell = snapshot2;
+        } else {
+            this.buy = snapshot2;
+            this.sell = snapshot1;
+        }
+    }
+
+    public long getTradedValue() {
+        return (long) price * quantity;
+    }
+
+    public void increaseSellersCredit() {
+        sell.getBroker().increaseCreditBy(getTradedValue());
+    }
+
+    public void decreaseBuyersCredit() {
+        buy.getBroker().decreaseCreditBy(getTradedValue());
+    }
+
+    public boolean buyerHasEnoughCredit() {
+        return buy.getBroker().hasEnoughCredit(getTradedValue());
+    }
+
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/CreditControl.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/CreditControl.java
new file mode 100644
index 0000000..583e980
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/CreditControl.java
@@ -0,0 +1,55 @@
+package ir.ramtung.tinyme.domain.service;
+
+import ir.ramtung.tinyme.domain.entity.Order;
+import ir.ramtung.tinyme.domain.entity.Side;
+import ir.ramtung.tinyme.domain.entity.Trade;
+import org.springframework.stereotype.Component;
+
+import java.util.LinkedList;
+import java.util.ListIterator;
+
+@Component
+public class CreditControl implements MatchingControl {
+    @Override
+    public MatchingOutcome canTrade(Order newOrder, Trade trade) {
+        if ((newOrder.getSide() == Side.SELL) || (newOrder.getSide() == Side.BUY && trade.buyerHasEnoughCredit())) {
+            return MatchingOutcome.OK;
+        } else return MatchingOutcome.NOT_ENOUGH_CREDIT;
+    }
+
+    @Override
+    public void tradeAccepted(Order newOrder, Trade trade) {
+        if (newOrder.getSide() == Side.BUY)
+            trade.decreaseBuyersCredit();
+        trade.increaseSellersCredit();
+    }
+
+    @Override
+    public MatchingOutcome canAcceptMatching(Order order, MatchResult result) {
+        if (result.remainder().getQuantity() > 0) {
+            if (order.getSide() == Side.BUY) {
+                if (!order.getBroker().hasEnoughCredit(order.getValue()))
+                    return MatchingOutcome.NOT_ENOUGH_CREDIT;
+            }
+        }
+        return MatchingOutcome.OK;
+    }
+
+    @Override
+    public void matchingAccepted(Order order, MatchResult result) {
+        if (order.getSide() == Side.BUY) {
+            order.getBroker().decreaseCreditBy(order.getValue());
+        }
+    }
+
+    @Override
+    public void rollbackTrades(Order newOrder, LinkedList<Trade> trades) {
+        if (newOrder.getSide() == Side.BUY) {
+            newOrder.getBroker().increaseCreditBy(trades.stream().mapToLong(Trade::getTradedValue).sum());
+            trades.forEach(trade -> trade.getSell().getBroker().decreaseCreditBy(trade.getTradedValue()));
+        } else {
+            newOrder.getBroker().decreaseCreditBy(trades.stream().mapToLong(Trade::getTradedValue).sum());
+            trades.forEach(trade -> trade.getSell().getBroker().increaseCreditBy(trade.getTradedValue()));
+        }
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/MatchResult.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/MatchResult.java
new file mode 100644
index 0000000..f0f0c90
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/MatchResult.java
@@ -0,0 +1,75 @@
+package ir.ramtung.tinyme.domain.service;
+
+import ir.ramtung.tinyme.domain.entity.Order;
+import ir.ramtung.tinyme.domain.entity.Trade;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Objects;
+
+public final class MatchResult {
+    private final MatchingOutcome outcome;
+    private final Order remainder;
+    private final LinkedList<Trade> trades;
+
+    public static MatchResult executed(Order remainder, List<Trade> trades) {
+        return new MatchResult(MatchingOutcome.OK, remainder, new LinkedList<>(trades));
+    }
+
+    public static MatchResult notEnoughCredit() {
+        return new MatchResult(MatchingOutcome.NOT_ENOUGH_CREDIT, null, new LinkedList<>());
+    }
+
+    public static MatchResult notEnoughPositions() {
+        return new MatchResult(MatchingOutcome.NOT_ENOUGH_POSITIONS, null, new LinkedList<>());
+    }
+
+    public static MatchResult minimumQuantityNotSatisfied() {
+        return new MatchResult(MatchingOutcome.MINIMUM_QUANTITY_NOT_SATISFIED, null, new LinkedList<>());
+    }
+
+    public MatchResult(MatchingOutcome outcome, Order remainder, LinkedList<Trade> trades) {
+        this.outcome = outcome;
+        this.remainder = remainder;
+        this.trades = trades;
+    }
+
+    public MatchResult(MatchingOutcome outcome, Order remainder) {
+        this(outcome, remainder, new LinkedList<>());
+    }
+
+    public MatchingOutcome outcome() {
+        return outcome;
+    }
+
+    public Order remainder() {
+        return remainder;
+    }
+
+    public LinkedList<Trade> trades() {
+        return trades;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (obj == this) return true;
+        if (obj == null || obj.getClass() != this.getClass()) return false;
+        var that = (MatchResult) obj;
+        return Objects.equals(this.remainder, that.remainder) &&
+                Objects.equals(this.trades, that.trades);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(remainder, trades);
+    }
+
+    @Override
+    public String toString() {
+        return "MatchResult[" +
+                "remainder=" + remainder + ", " +
+                "trades=" + trades + ']';
+    }
+
+
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/Matcher.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/Matcher.java
new file mode 100644
index 0000000..2431b45
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/Matcher.java
@@ -0,0 +1,86 @@
+package ir.ramtung.tinyme.domain.service;
+
+import ir.ramtung.tinyme.domain.entity.*;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Service;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.ListIterator;
+
+@Service
+public class Matcher {
+    @Autowired
+    private MatchingControlList controls;
+
+    public MatchResult match(Order newOrder) {
+        OrderBook orderBook = newOrder.getSecurity().getOrderBook();
+        LinkedList<Trade> trades = new LinkedList<>();
+
+        while (orderBook.hasOrderOfType(newOrder.getSide().opposite()) && newOrder.getQuantity() > 0) {
+            Order matchingOrder = orderBook.matchWithFirst(newOrder);
+            if (matchingOrder == null)
+                break;
+
+            Trade trade = new Trade(newOrder.getSecurity(), matchingOrder.getPrice(), Math.min(newOrder.getQuantity(), matchingOrder.getQuantity()), newOrder, matchingOrder);
+            MatchingOutcome outcome = controls.canTrade(newOrder, trade);
+            if (outcome != MatchingOutcome.OK) {
+                rollbackTrades(newOrder, trades);
+                return new MatchResult(outcome, newOrder);
+            }
+            trades.add(trade);
+            controls.tradeAccepted(newOrder, trade);
+
+            if (newOrder.getQuantity() >= matchingOrder.getQuantity()) {
+                newOrder.decreaseQuantity(matchingOrder.getQuantity());
+                orderBook.removeFirst(matchingOrder.getSide());
+                if (matchingOrder instanceof IcebergOrder icebergOrder) {
+                    icebergOrder.decreaseQuantity(matchingOrder.getQuantity());
+                    icebergOrder.replenish();
+                    if (icebergOrder.getQuantity() > 0)
+                        orderBook.enqueue(icebergOrder);
+                }
+            } else {
+                matchingOrder.decreaseQuantity(newOrder.getQuantity());
+                newOrder.makeQuantityZero();
+            }
+        }
+        return MatchResult.executed(newOrder, trades);
+    }
+
+    private void rollbackTrades(Order newOrder, LinkedList<Trade> trades) {
+        ListIterator<Trade> it = trades.listIterator(trades.size());
+        while (it.hasPrevious()) {
+            if (newOrder.getSide() == Side.BUY)
+                newOrder.getSecurity().getOrderBook().restoreOrder(it.previous().getSell());
+            else
+                newOrder.getSecurity().getOrderBook().restoreOrder(it.previous().getBuy());
+        }
+    }
+
+    public MatchResult execute(Order order) {
+        MatchingOutcome outcome = controls.canStartMatching(order);
+        if (outcome != MatchingOutcome.OK)
+            return new MatchResult(outcome, order);
+
+        controls.matchingStarted(order);
+
+        MatchResult result = match(order);
+        if (result.outcome() != MatchingOutcome.OK)
+            return result;
+
+        outcome = controls.canAcceptMatching(order, result);
+        if (outcome != MatchingOutcome.OK) {
+            controls.rollbackTrades(order, result.trades());
+            rollbackTrades(order, result.trades());
+            return new MatchResult(outcome, order);
+        }
+
+        if (result.remainder().getQuantity() > 0) {
+            order.getSecurity().getOrderBook().enqueue(result.remainder());
+        }
+
+        controls.matchingAccepted(order, result);
+        return result;
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/MatchingControl.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/MatchingControl.java
new file mode 100644
index 0000000..e805f71
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/MatchingControl.java
@@ -0,0 +1,18 @@
+package ir.ramtung.tinyme.domain.service;
+
+import ir.ramtung.tinyme.domain.entity.Order;
+import ir.ramtung.tinyme.domain.entity.Trade;
+
+import java.util.LinkedList;
+
+public interface MatchingControl {
+    default MatchingOutcome canStartMatching(Order order) { return MatchingOutcome.OK; }
+    default void matchingStarted(Order order) {}
+    default MatchingOutcome canAcceptMatching(Order order, MatchResult result) { return MatchingOutcome.OK; }
+    default void matchingAccepted(Order order, MatchResult result) {}
+
+    default MatchingOutcome canTrade(Order newOrder, Trade trade) { return MatchingOutcome.OK; }
+    default void tradeAccepted(Order newOrder, Trade trade) {}
+
+    default void rollbackTrades(Order newOrder, LinkedList<Trade> trades) {}
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/MatchingControlList.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/MatchingControlList.java
new file mode 100644
index 0000000..5b83853
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/MatchingControlList.java
@@ -0,0 +1,59 @@
+package ir.ramtung.tinyme.domain.service;
+
+import ir.ramtung.tinyme.domain.entity.Order;
+import ir.ramtung.tinyme.domain.entity.Trade;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+import java.util.LinkedList;
+import java.util.List;
+
+@Component
+public class MatchingControlList {
+    @Autowired
+    private List<MatchingControl> controlList;
+
+    public MatchingOutcome canStartMatching(Order order) {
+        for (MatchingControl control : controlList) {
+            MatchingOutcome outcome = control.canStartMatching(order);
+            if (outcome != MatchingOutcome.OK)
+                return outcome;
+        }
+        return MatchingOutcome.OK;
+    }
+    public void matchingStarted(Order order) {
+        for (MatchingControl control : controlList) {
+            control.matchingStarted(order);
+        }
+    }
+    public MatchingOutcome canAcceptMatching(Order order, MatchResult result) {
+        for (MatchingControl control : controlList) {
+            MatchingOutcome outcome = control.canAcceptMatching(order, result);
+            if (outcome != MatchingOutcome.OK) {
+                return outcome;
+            }
+        }
+        return MatchingOutcome.OK;
+    }
+    public void matchingAccepted(Order order, MatchResult result) {
+        for (MatchingControl control : controlList) {
+            control.matchingAccepted(order, result);
+        }
+    }
+
+    public MatchingOutcome canTrade(Order newOrder, Trade trade) { return MatchingOutcome.OK; }
+
+    public void tradeAccepted(Order newOrder, Trade trade) {
+        for (MatchingControl control : controlList) {
+            control.tradeAccepted(newOrder, trade);
+        }
+    }
+
+    public void rollbackTrades(Order newOrder, LinkedList<Trade> trades) {
+        for (MatchingControl control2 : controlList) {
+            control2.rollbackTrades(newOrder, trades);
+        }
+
+    }
+
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/MatchingOutcome.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/MatchingOutcome.java
new file mode 100644
index 0000000..23d4a31
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/MatchingOutcome.java
@@ -0,0 +1,8 @@
+package ir.ramtung.tinyme.domain.service;
+
+public enum MatchingOutcome {
+    OK,
+    NOT_ENOUGH_CREDIT,
+    NOT_ENOUGH_POSITIONS,
+    MINIMUM_QUANTITY_NOT_SATISFIED
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/MinimumExecutionQuantityControl.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/MinimumExecutionQuantityControl.java
new file mode 100644
index 0000000..900e7ef
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/MinimumExecutionQuantityControl.java
@@ -0,0 +1,13 @@
+package ir.ramtung.tinyme.domain.service;
+
+import ir.ramtung.tinyme.domain.entity.Order;
+import org.springframework.stereotype.Component;
+
+@Component
+public class MinimumExecutionQuantityControl implements MatchingControl {
+    public MatchingOutcome canAcceptMatching(Order order, MatchResult result) {
+        if (order.minimumExecutionQuantitySatisfied())
+            return MatchingOutcome.OK;
+        else return MatchingOutcome.MINIMUM_QUANTITY_NOT_SATISFIED;
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/OrderHandler.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/OrderHandler.java
new file mode 100644
index 0000000..2350691
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/OrderHandler.java
@@ -0,0 +1,127 @@
+package ir.ramtung.tinyme.domain.service;
+
+import ir.ramtung.tinyme.domain.entity.*;
+import ir.ramtung.tinyme.messaging.Message;
+import ir.ramtung.tinyme.messaging.exception.InvalidRequestException;
+import ir.ramtung.tinyme.messaging.EventPublisher;
+import ir.ramtung.tinyme.messaging.TradeDTO;
+import ir.ramtung.tinyme.messaging.event.*;
+import ir.ramtung.tinyme.messaging.request.DeleteOrderRq;
+import ir.ramtung.tinyme.messaging.request.EnterOrderRq;
+import ir.ramtung.tinyme.messaging.request.OrderEntryType;
+import ir.ramtung.tinyme.repository.BrokerRepository;
+import ir.ramtung.tinyme.repository.SecurityRepository;
+import ir.ramtung.tinyme.repository.ShareholderRepository;
+import org.springframework.stereotype.Service;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.stream.Collectors;
+
+@Service
+public class OrderHandler {
+    SecurityRepository securityRepository;
+    BrokerRepository brokerRepository;
+    ShareholderRepository shareholderRepository;
+    EventPublisher eventPublisher;
+    Matcher matcher;
+
+    public OrderHandler(SecurityRepository securityRepository, BrokerRepository brokerRepository, ShareholderRepository shareholderRepository, EventPublisher eventPublisher, Matcher matcher) {
+        this.securityRepository = securityRepository;
+        this.brokerRepository = brokerRepository;
+        this.shareholderRepository = shareholderRepository;
+        this.eventPublisher = eventPublisher;
+        this.matcher = matcher;
+    }
+
+    public void handleEnterOrder(EnterOrderRq enterOrderRq) {
+        try {
+            validateEnterOrderRq(enterOrderRq);
+
+            Security security = securityRepository.findSecurityByIsin(enterOrderRq.getSecurityIsin());
+            Broker broker = brokerRepository.findBrokerById(enterOrderRq.getBrokerId());
+            Shareholder shareholder = shareholderRepository.findShareholderById(enterOrderRq.getShareholderId());
+
+            MatchResult matchResult;
+            if (enterOrderRq.getRequestType() == OrderEntryType.NEW_ORDER)
+                matchResult = security.newOrder(enterOrderRq, broker, shareholder, matcher);
+            else
+                matchResult = security.updateOrder(enterOrderRq, matcher);
+
+            if (matchResult.outcome() == MatchingOutcome.NOT_ENOUGH_CREDIT) {
+                eventPublisher.publish(new OrderRejectedEvent(enterOrderRq.getRequestId(), enterOrderRq.getOrderId(), List.of(Message.BUYER_HAS_NOT_ENOUGH_CREDIT)));
+                return;
+            }
+            if (matchResult.outcome() == MatchingOutcome.NOT_ENOUGH_POSITIONS) {
+                eventPublisher.publish(new OrderRejectedEvent(enterOrderRq.getRequestId(), enterOrderRq.getOrderId(), List.of(Message.SELLER_HAS_NOT_ENOUGH_POSITIONS)));
+                return;
+            }
+            if (enterOrderRq.getRequestType() == OrderEntryType.NEW_ORDER)
+                eventPublisher.publish(new OrderAcceptedEvent(enterOrderRq.getRequestId(), enterOrderRq.getOrderId()));
+            else
+                eventPublisher.publish(new OrderUpdatedEvent(enterOrderRq.getRequestId(), enterOrderRq.getOrderId()));
+            if (!matchResult.trades().isEmpty()) {
+                eventPublisher.publish(new OrderExecutedEvent(enterOrderRq.getRequestId(), enterOrderRq.getOrderId(), matchResult.trades().stream().map(TradeDTO::new).collect(Collectors.toList())));
+            }
+        } catch (InvalidRequestException ex) {
+            eventPublisher.publish(new OrderRejectedEvent(enterOrderRq.getRequestId(), enterOrderRq.getOrderId(), ex.getReasons()));
+        }
+    }
+
+    public void handleDeleteOrder(DeleteOrderRq deleteOrderRq) {
+        try {
+            validateDeleteOrderRq(deleteOrderRq);
+            Security security = securityRepository.findSecurityByIsin(deleteOrderRq.getSecurityIsin());
+            security.deleteOrder(deleteOrderRq);
+            eventPublisher.publish(new OrderDeletedEvent(deleteOrderRq.getRequestId(), deleteOrderRq.getOrderId()));
+        } catch (InvalidRequestException ex) {
+            eventPublisher.publish(new OrderRejectedEvent(deleteOrderRq.getRequestId(), deleteOrderRq.getOrderId(), ex.getReasons()));
+        }
+    }
+
+    private void validateEnterOrderRq(EnterOrderRq enterOrderRq) throws InvalidRequestException {
+        List<String> errors = new LinkedList<>();
+        if (enterOrderRq.getOrderId() <= 0)
+            errors.add(Message.INVALID_ORDER_ID);
+        if (enterOrderRq.getQuantity() <= 0)
+            errors.add(Message.ORDER_QUANTITY_NOT_POSITIVE);
+        if (enterOrderRq.getPrice() <= 0)
+            errors.add(Message.ORDER_PRICE_NOT_POSITIVE);
+        Security security = securityRepository.findSecurityByIsin(enterOrderRq.getSecurityIsin());
+        if (security == null)
+            errors.add(Message.UNKNOWN_SECURITY_ISIN);
+        else {
+            if (enterOrderRq.getQuantity() % security.getLotSize() != 0)
+                errors.add(Message.QUANTITY_NOT_MULTIPLE_OF_LOT_SIZE);
+            if (enterOrderRq.getPrice() % security.getTickSize() != 0)
+                errors.add(Message.PRICE_NOT_MULTIPLE_OF_TICK_SIZE);
+        }
+        if (brokerRepository.findBrokerById(enterOrderRq.getBrokerId()) == null)
+            errors.add(Message.UNKNOWN_BROKER_ID);
+        if (shareholderRepository.findShareholderById(enterOrderRq.getShareholderId()) == null)
+            errors.add(Message.UNKNOWN_SHAREHOLDER_ID);
+        if (enterOrderRq.getPeakSize() < 0 || enterOrderRq.getPeakSize() >= enterOrderRq.getQuantity())
+            errors.add(Message.INVALID_PEAK_SIZE);
+
+        if (enterOrderRq.getMinimumExecutionQuantity() != 0) {
+            if (enterOrderRq.getMinimumExecutionQuantity() < 0)
+                errors.add(Message.MEQ_NOT_POSITIVE);
+            if (enterOrderRq.getRequestType() != OrderEntryType.NEW_ORDER)
+                errors.add(Message.MEQ_ON_UPDATE);
+            if (enterOrderRq.getMinimumExecutionQuantity() > enterOrderRq.getQuantity())
+                errors.add(Message.INVALID_MEQ);
+        }
+        if (!errors.isEmpty())
+            throw new InvalidRequestException(errors);
+    }
+
+    private void validateDeleteOrderRq(DeleteOrderRq deleteOrderRq) throws InvalidRequestException {
+        List<String> errors = new LinkedList<>();
+        if (deleteOrderRq.getOrderId() <= 0)
+            errors.add(Message.INVALID_ORDER_ID);
+        if (securityRepository.findSecurityByIsin(deleteOrderRq.getSecurityIsin()) == null)
+            errors.add(Message.UNKNOWN_SECURITY_ISIN);
+        if (!errors.isEmpty())
+            throw new InvalidRequestException(errors);
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/OwnershipControl.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/OwnershipControl.java
new file mode 100644
index 0000000..f84d09e
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/domain/service/OwnershipControl.java
@@ -0,0 +1,23 @@
+package ir.ramtung.tinyme.domain.service;
+
+import ir.ramtung.tinyme.domain.entity.Order;
+import ir.ramtung.tinyme.domain.entity.Side;
+import ir.ramtung.tinyme.domain.entity.Trade;
+import org.springframework.stereotype.Component;
+
+@Component
+public class OwnershipControl implements MatchingControl {
+    public MatchingOutcome canStartMatching(Order order) {
+        if (order.getSide() == Side.SELL &&
+                !order.getShareholder().hasEnoughPositionsOn(order.getSecurity(),
+                        order.getSecurity().getOrderBook().totalSellQuantityByShareholder(order.getShareholder()) + order.getQuantity()))
+            return MatchingOutcome.NOT_ENOUGH_POSITIONS;
+        return MatchingOutcome.OK;
+    }
+    public void matchingAccepted(Order order, MatchResult result) {
+        for (Trade trade : result.trades()) {
+            trade.getBuy().getShareholder().incPosition(trade.getSecurity(), trade.getQuantity());
+            trade.getSell().getShareholder().decPosition(trade.getSecurity(), trade.getQuantity());
+        }
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/EventPublisher.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/EventPublisher.java
new file mode 100644
index 0000000..b97caef
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/EventPublisher.java
@@ -0,0 +1,25 @@
+package ir.ramtung.tinyme.messaging;
+
+import ir.ramtung.tinyme.messaging.event.Event;
+import org.springframework.beans.factory.annotation.Value;
+import org.springframework.jms.core.JmsTemplate;
+import org.springframework.stereotype.Component;
+
+import java.util.logging.Logger;
+
+@Component
+public class EventPublisher {
+    private final Logger log = Logger.getLogger(this.getClass().getName());
+    private final JmsTemplate jmsTemplate;
+    @Value("${responseQueue}")
+    private String responseQueue;
+
+    public EventPublisher(JmsTemplate jmsTemplate) {
+        this.jmsTemplate = jmsTemplate;
+    }
+
+    public void publish(Event event) {
+        log.info("Published : " + event);
+        jmsTemplate.convertAndSend(responseQueue, event);
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/Message.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/Message.java
new file mode 100644
index 0000000..6d2c9ed
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/Message.java
@@ -0,0 +1,20 @@
+package ir.ramtung.tinyme.messaging;
+
+public class Message {
+    public static final String INVALID_ORDER_ID = "Invalid order ID";
+    public static final String ORDER_QUANTITY_NOT_POSITIVE = "Order quantity is not-positive";
+    public static final String ORDER_PRICE_NOT_POSITIVE = "Order price is not-positive";
+    public static final String UNKNOWN_SECURITY_ISIN = "Unknown security ISIN";
+    public static final String ORDER_ID_NOT_FOUND = "Order ID not found in the order book";
+    public static final String INVALID_PEAK_SIZE = "Iceberg order peak size is out of range";
+    public static final String CANNOT_SPECIFY_PEAK_SIZE_FOR_A_NON_ICEBERG_ORDER = "Cannot specify peak size for a non-iceberg order";
+    public static final String UNKNOWN_BROKER_ID = "Unknown broker ID";
+    public static final String UNKNOWN_SHAREHOLDER_ID = "Unknown shareholder ID";
+    public static final String BUYER_HAS_NOT_ENOUGH_CREDIT = "Buyer has not enough credit";
+    public static final String QUANTITY_NOT_MULTIPLE_OF_LOT_SIZE = "Quantity is not a multiple of security lot size";
+    public static final String PRICE_NOT_MULTIPLE_OF_TICK_SIZE = "Price is not a multiple of security tick size";
+    public static final String SELLER_HAS_NOT_ENOUGH_POSITIONS = "Seller has not enough positions";
+    public static final String INVALID_MEQ="Minimum execution quantity can't be bigger than quantity";
+    public static final String MEQ_ON_UPDATE="Minimum execution quantity can only be specified for new orders";
+    public static final String MEQ_NOT_POSITIVE = "Minimum execution quantity must be positive or zero";
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/MessagingConfig.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/MessagingConfig.java
new file mode 100644
index 0000000..1fb60cc
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/MessagingConfig.java
@@ -0,0 +1,18 @@
+package ir.ramtung.tinyme.messaging;
+
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.jms.support.converter.MappingJackson2MessageConverter;
+import org.springframework.jms.support.converter.MessageConverter;
+import org.springframework.jms.support.converter.MessageType;
+
+@Configuration
+public class MessagingConfig {
+    @Bean
+    public MessageConverter jacksonJmsMessageConverter() {
+        MappingJackson2MessageConverter converter = new MappingJackson2MessageConverter();
+        converter.setTargetType(MessageType.TEXT);
+        converter.setTypeIdPropertyName("_type");
+        return converter;
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/RequestDispatcher.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/RequestDispatcher.java
new file mode 100644
index 0000000..5165ddd
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/RequestDispatcher.java
@@ -0,0 +1,31 @@
+package ir.ramtung.tinyme.messaging;
+
+import ir.ramtung.tinyme.messaging.request.DeleteOrderRq;
+import ir.ramtung.tinyme.messaging.request.EnterOrderRq;
+import ir.ramtung.tinyme.domain.service.OrderHandler;
+import org.springframework.jms.annotation.JmsListener;
+import org.springframework.stereotype.Component;
+
+import java.util.logging.Logger;
+
+@Component
+public class RequestDispatcher {
+    private final Logger log = Logger.getLogger(this.getClass().getName());
+    private final OrderHandler orderHandler;
+
+    public RequestDispatcher(OrderHandler orderHandler) {
+        this.orderHandler = orderHandler;
+    }
+
+    @JmsListener(destination = "${requestQueue}", selector = "_type='ir.ramtung.tinyme.messaging.request.EnterOrderRq'")
+    public void receiveEnterOrderRq(EnterOrderRq enterOrderRq) {
+        log.info("Received message: " + enterOrderRq);
+        orderHandler.handleEnterOrder(enterOrderRq);
+    }
+
+    @JmsListener(destination = "${requestQueue}", selector = "_type='ir.ramtung.tinyme.messaging.request.DeleteOrderRq'")
+    public void receiveDeleteOrderRq(DeleteOrderRq deleteOrderRq) {
+        log.info("Received message: " + deleteOrderRq);
+        orderHandler.handleDeleteOrder(deleteOrderRq);
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/TradeDTO.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/TradeDTO.java
new file mode 100644
index 0000000..42c101e
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/TradeDTO.java
@@ -0,0 +1,15 @@
+package ir.ramtung.tinyme.messaging;
+
+import ir.ramtung.tinyme.domain.entity.Trade;
+
+public record TradeDTO(
+    String securityIsin,
+    int price,
+    int quantity,
+    long buyOrderId,
+    long sellOrderId) {
+
+    public TradeDTO(Trade trade) {
+        this(trade.getSecurity().getIsin(), trade.getPrice(), trade.getQuantity(), trade.getBuy().getOrderId(), trade.getSell().getOrderId());
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/event/Event.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/event/Event.java
new file mode 100644
index 0000000..e05de03
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/event/Event.java
@@ -0,0 +1,24 @@
+package ir.ramtung.tinyme.messaging.event;
+
+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
+import com.fasterxml.jackson.databind.annotation.JsonSerialize;
+import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
+import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
+import lombok.EqualsAndHashCode;
+import lombok.Getter;
+
+import java.time.LocalDateTime;
+
+@EqualsAndHashCode
+public abstract class Event {
+    @Getter
+    @JsonSerialize(using = LocalDateTimeSerializer.class)
+    @JsonDeserialize(using = LocalDateTimeDeserializer.class)
+    private final LocalDateTime time;
+    public Event() {
+        time = LocalDateTime.now();
+    }
+    public Event(LocalDateTime time) {
+        this.time = time;
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/event/OrderAcceptedEvent.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/event/OrderAcceptedEvent.java
new file mode 100644
index 0000000..2145564
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/event/OrderAcceptedEvent.java
@@ -0,0 +1,15 @@
+package ir.ramtung.tinyme.messaging.event;
+
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.NoArgsConstructor;
+
+@Data
+@EqualsAndHashCode(callSuper = false)
+@AllArgsConstructor
+@NoArgsConstructor
+public class OrderAcceptedEvent extends Event {
+    private long requestId;
+    private long orderId;
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/event/OrderDeletedEvent.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/event/OrderDeletedEvent.java
new file mode 100644
index 0000000..da3b1e3
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/event/OrderDeletedEvent.java
@@ -0,0 +1,15 @@
+package ir.ramtung.tinyme.messaging.event;
+
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.NoArgsConstructor;
+
+@Data
+@EqualsAndHashCode(callSuper = false)
+@AllArgsConstructor
+@NoArgsConstructor
+public class OrderDeletedEvent extends Event {
+    private long requestId;
+    private long orderId;
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/event/OrderExecutedEvent.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/event/OrderExecutedEvent.java
new file mode 100644
index 0000000..4c829cf
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/event/OrderExecutedEvent.java
@@ -0,0 +1,19 @@
+package ir.ramtung.tinyme.messaging.event;
+
+import ir.ramtung.tinyme.messaging.TradeDTO;
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.NoArgsConstructor;
+
+import java.util.List;
+
+@Data
+@EqualsAndHashCode(callSuper = false)
+@AllArgsConstructor
+@NoArgsConstructor
+public class OrderExecutedEvent extends Event {
+    private long requestId;
+    private long orderId;
+    private List<TradeDTO> trades;
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/event/OrderRejectedEvent.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/event/OrderRejectedEvent.java
new file mode 100644
index 0000000..e2fb923
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/event/OrderRejectedEvent.java
@@ -0,0 +1,18 @@
+package ir.ramtung.tinyme.messaging.event;
+
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.NoArgsConstructor;
+
+import java.util.List;
+
+@Data
+@EqualsAndHashCode(callSuper = false)
+@AllArgsConstructor
+@NoArgsConstructor
+public class OrderRejectedEvent extends Event {
+    private long requestId;
+    private long orderId;
+    private List<String> errors;
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/event/OrderUpdatedEvent.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/event/OrderUpdatedEvent.java
new file mode 100644
index 0000000..e8eda6c
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/event/OrderUpdatedEvent.java
@@ -0,0 +1,15 @@
+package ir.ramtung.tinyme.messaging.event;
+
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.NoArgsConstructor;
+
+@Data
+@EqualsAndHashCode(callSuper = false)
+@AllArgsConstructor
+@NoArgsConstructor
+public class OrderUpdatedEvent extends Event {
+    private long requestId;
+    private long orderId;
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/exception/InvalidRequestException.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/exception/InvalidRequestException.java
new file mode 100644
index 0000000..7bd6e59
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/exception/InvalidRequestException.java
@@ -0,0 +1,22 @@
+package ir.ramtung.tinyme.messaging.exception;
+
+import lombok.Getter;
+import lombok.ToString;
+
+import java.util.List;
+
+@ToString
+public class InvalidRequestException extends Exception {
+    @Getter
+    private final List<String> reasons;
+
+    public InvalidRequestException(List<String> reasons) {
+        this.reasons = reasons;
+    }
+
+    public InvalidRequestException(String reason) {
+        this.reasons = List.of(reason);
+    }
+
+
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/request/DeleteOrderRq.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/request/DeleteOrderRq.java
new file mode 100644
index 0000000..577a736
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/request/DeleteOrderRq.java
@@ -0,0 +1,33 @@
+package ir.ramtung.tinyme.messaging.request;
+
+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
+import com.fasterxml.jackson.databind.annotation.JsonSerialize;
+import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
+import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
+import ir.ramtung.tinyme.domain.entity.Side;
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+import java.time.LocalDateTime;
+
+@Data
+@AllArgsConstructor
+@NoArgsConstructor
+public class DeleteOrderRq {
+    private long requestId;
+    private String securityIsin;
+    private Side side;
+    private long orderId;
+    @JsonSerialize(using = LocalDateTimeSerializer.class)
+    @JsonDeserialize(using = LocalDateTimeDeserializer.class)
+    private LocalDateTime entryTime;
+
+    public DeleteOrderRq(long requestId, String securityIsin, Side side, long orderId) {
+        this.requestId = requestId;
+        this.securityIsin = securityIsin;
+        this.side = side;
+        this.orderId = orderId;
+        this.entryTime = LocalDateTime.now();
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/request/EnterOrderRq.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/request/EnterOrderRq.java
new file mode 100644
index 0000000..4471809
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/request/EnterOrderRq.java
@@ -0,0 +1,54 @@
+package ir.ramtung.tinyme.messaging.request;
+
+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
+import com.fasterxml.jackson.databind.annotation.JsonSerialize;
+import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
+import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
+import ir.ramtung.tinyme.domain.entity.Side;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+import java.time.LocalDateTime;
+
+@Data
+@NoArgsConstructor
+public class EnterOrderRq {
+    private OrderEntryType requestType;
+    private long requestId;
+    private String securityIsin;
+    private long orderId;
+    @JsonSerialize(using = LocalDateTimeSerializer.class)
+    @JsonDeserialize(using = LocalDateTimeDeserializer.class)
+    private LocalDateTime entryTime;
+    private Side side;
+    private int quantity;
+    private int minimumExecutionQuantity;
+    private int price;
+    private long brokerId;
+    private long shareholderId;
+    private int peakSize;
+
+    private EnterOrderRq(OrderEntryType orderEntryType, long requestId, String securityIsin, long orderId, LocalDateTime entryTime, Side side, int quantity, int price, long brokerId, long shareholderId, int peakSize, int minimumExecutionQuantity) {
+        this.requestType = orderEntryType;
+        this.requestId = requestId;
+        this.securityIsin = securityIsin;
+        this.orderId = orderId;
+        this.entryTime = entryTime;
+        this.side = side;
+        this.quantity = quantity;
+        this.price = price;
+        this.brokerId = brokerId;
+        this.shareholderId = shareholderId;
+        this.peakSize = peakSize;
+        this.minimumExecutionQuantity = minimumExecutionQuantity;
+    }
+
+    public static EnterOrderRq createNewOrderRq(long requestId, String securityIsin, long orderId, LocalDateTime entryTime, Side side, int quantity, int price, long brokerId, long shareholderId, int peakSize, int minimumExecutionQuantity) {
+        return new EnterOrderRq(OrderEntryType.NEW_ORDER, requestId, securityIsin, orderId, entryTime, side, quantity, price, brokerId, shareholderId, peakSize, minimumExecutionQuantity);
+    }
+
+    public static EnterOrderRq createUpdateOrderRq(long requestId, String securityIsin, long orderId, LocalDateTime entryTime, Side side, int quantity, int price, long brokerId, long shareholderId, int peakSize) {
+        return new EnterOrderRq(OrderEntryType.UPDATE_ORDER, requestId, securityIsin, orderId, entryTime, side, quantity, price, brokerId, shareholderId, peakSize, 0);
+    }
+
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/request/OrderEntryType.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/request/OrderEntryType.java
new file mode 100644
index 0000000..cf2358f
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/messaging/request/OrderEntryType.java
@@ -0,0 +1,6 @@
+package ir.ramtung.tinyme.messaging.request;
+
+public enum OrderEntryType {
+    NEW_ORDER,
+    UPDATE_ORDER
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/repository/BrokerRepository.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/repository/BrokerRepository.java
new file mode 100644
index 0000000..e50bfa0
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/repository/BrokerRepository.java
@@ -0,0 +1,24 @@
+package ir.ramtung.tinyme.repository;
+
+import ir.ramtung.tinyme.domain.entity.Broker;
+import org.springframework.stereotype.Component;
+
+import java.util.HashMap;
+
+@Component
+public class BrokerRepository {
+    private final HashMap<Long, Broker> brokerById = new HashMap<>();
+    public Broker findBrokerById(long brokerId) {
+        return brokerById.get(brokerId);
+    }
+    public void addBroker(Broker broker) {
+        brokerById.put(broker.getBrokerId(), broker);
+    }
+
+    public void clear() {
+        brokerById.clear();
+    }
+    Iterable<? extends Broker> allBrokers() {
+        return brokerById.values();
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/repository/DataLoader.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/repository/DataLoader.java
new file mode 100644
index 0000000..9a11a24
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/repository/DataLoader.java
@@ -0,0 +1,261 @@
+package ir.ramtung.tinyme.repository;
+
+import com.opencsv.CSVReader;
+import com.opencsv.CSVReaderBuilder;
+import ir.ramtung.tinyme.domain.entity.*;
+import jakarta.annotation.PostConstruct;
+import jakarta.annotation.PreDestroy;
+import org.springframework.beans.factory.annotation.Value;
+import org.springframework.context.annotation.Profile;
+import org.springframework.core.io.Resource;
+import org.springframework.stereotype.Component;
+
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.io.PrintWriter;
+import java.io.Reader;
+import java.time.LocalDateTime;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.StringJoiner;
+import java.util.logging.Logger;
+
+@Component
+@Profile("!test")
+public class DataLoader {
+    private final Logger log = Logger.getLogger(this.getClass().getName());
+    private final BrokerRepository brokerRepository;
+    private final ShareholderRepository shareholderRepository;
+    private final SecurityRepository securityRepository;
+
+    public DataLoader(BrokerRepository brokerRepository, ShareholderRepository shareholderRepository, SecurityRepository securityRepository) {
+        this.brokerRepository = brokerRepository;
+        this.shareholderRepository = shareholderRepository;
+        this.securityRepository = securityRepository;
+    }
+
+    @Value("classpath:persistence/broker.csv")
+    private Resource brokerCsvResource;
+    @Value("classpath:persistence/shareholder.csv")
+    private Resource shareholderCsvResource;
+    @Value("classpath:persistence/security.csv")
+    private Resource securityCsvResource;
+    @Value("classpath:persistence/position.csv")
+    private Resource positionCsvResource;
+    @Value("classpath:persistence/orderbook.csv")
+    private Resource orderBookCsvResource;
+
+    @PostConstruct
+    public void loadAll() throws Exception {
+        loadBrokers();
+        loadShareholders();
+        loadSecurities();
+        loadPositions();
+        loadOrderBook();
+    }
+
+    @PreDestroy
+    public void saveAll() throws Exception {
+        System.out.print("Saving persistent data ...");
+        saveBrokers();
+        saveShareholdersAndPositions();
+        saveSecuritiesAndOrderBooks();
+        System.out.println(", done!");
+    }
+
+    private void loadBrokers() throws Exception {
+        brokerRepository.clear();
+      try (Reader reader = new FileReader(brokerCsvResource.getFile())) {
+            try (CSVReader csvReader = new CSVReaderBuilder(reader).withSkipLines(1).build()) {
+                String[] line;
+                while ((line = csvReader.readNext()) != null) {
+                    brokerRepository.addBroker(Broker.builder()
+                            .brokerId(Long.parseLong(line[0]))
+                            .name(line[1])
+                            .credit(Long.parseLong(line[0]))
+                            .build());
+                }
+            }
+        }
+        log.info("Brokers loaded");
+    }
+
+    private void loadShareholders() throws Exception {
+        shareholderRepository.clear();
+        try (Reader reader = new FileReader(shareholderCsvResource.getFile())) {
+            try (CSVReader csvReader = new CSVReaderBuilder(reader).withSkipLines(1).build()) {
+                String[] line;
+                while ((line = csvReader.readNext()) != null) {
+                    shareholderRepository.addShareholder(Shareholder.builder()
+                            .shareholderId(Long.parseLong(line[0]))
+                            .name(line[1])
+                            .build());
+                }
+            }
+        }
+        log.info("Shareholders loaded");
+    }
+
+    private void loadSecurities() throws Exception {
+        securityRepository.clear();
+        try (Reader reader = new FileReader(securityCsvResource.getFile())) {
+            try (CSVReader csvReader = new CSVReaderBuilder(reader).withSkipLines(1).build()) {
+                String[] line;
+                while ((line = csvReader.readNext()) != null) {
+                    securityRepository.addSecurity(Security.builder()
+                            .isin(line[0])
+                            .tickSize(Integer.parseInt(line[1]))
+                            .lotSize(Integer.parseInt(line[2]))
+                            .build());
+                }
+            }
+        }
+        log.info("Securities loaded");
+    }
+
+    private void loadPositions() throws Exception {
+        try (Reader reader = new FileReader(positionCsvResource.getFile())) {
+            try (CSVReader csvReader = new CSVReaderBuilder(reader).withSkipLines(1).build()) {
+                String[] line;
+                while ((line = csvReader.readNext()) != null) {
+                    Shareholder shareholder = shareholderRepository.findShareholderById(Long.parseLong(line[0]));
+                    Security security = securityRepository.findSecurityByIsin(line[1]);
+                    shareholder.incPosition(security, Integer.parseInt(line[2]));
+                }
+            }
+        }
+        log.info("Positions loaded");
+    }
+
+    private void loadOrderBook() throws Exception {
+        LinkedList<Order> orders = new LinkedList<>();
+        try (Reader reader = new FileReader(orderBookCsvResource.getFile())) {
+            try (CSVReader csvReader = new CSVReaderBuilder(reader).withSkipLines(1).build()) {
+                String[] line;
+                while ((line = csvReader.readNext()) != null) {
+                    Security security = securityRepository.findSecurityByIsin(line[1]);
+                    Broker broker = brokerRepository.findBrokerById(Long.parseLong(line[6]));
+                    Shareholder shareholder = shareholderRepository.findShareholderById(Long.parseLong(line[7]));
+//orderId,isin,side,initialQuantity,quantity,price,brokerId,shareholderId,entryTime,peakSize,displayedQuantity, minimumExecutionQuantity
+//0       1    2    3                4        5    6        7              8        9        10                 11
+                    int peakSize = Integer.parseInt(line[8]);
+                    Order order;
+                    if (peakSize == 0) {
+                        order = new Order(
+                                Long.parseLong(line[0]),
+                                security,
+                                Side.parse(line[2]),
+                                Integer.parseInt(line[3]),
+                                Integer.parseInt(line[4]),
+                                Integer.parseInt(line[5]),
+                                broker,
+                                shareholder,
+                                LocalDateTime.parse(line[8]),
+                                Integer.parseInt(line[11]),
+                                OrderStatus.QUEUED);
+                    } else {
+                        order = new IcebergOrder(
+                                Long.parseLong(line[0]),
+                                security,
+                                Side.parse(line[2]),
+                                Integer.parseInt(line[3]),
+                                Integer.parseInt(line[4]),
+                                Integer.parseInt(line[5]),
+                                broker,
+                                shareholder,
+                                LocalDateTime.parse(line[8]),
+                                Integer.parseInt(line[9]),
+                                Integer.parseInt(line[10]),
+                                Integer.parseInt(line[11]),
+                                OrderStatus.QUEUED);
+                    }
+                    orders.addFirst(order);
+                }
+            }
+        }
+        Iterator<Order> it = orders.descendingIterator();
+        while (it.hasNext()) {
+            Order order = it.next();
+            order.getSecurity().getOrderBook().enqueue(order);
+        }
+        log.info("Order Book loaded");
+    }
+
+    private void saveBrokers() throws Exception {
+        try (PrintWriter writer = new PrintWriter(new FileWriter(brokerCsvResource.getFile()))) {
+            writer.println("brokerId,name,credit");
+            for (Broker broker : brokerRepository.allBrokers()) {
+                StringJoiner joiner = new StringJoiner(",");
+                joiner.add(String.valueOf(broker.getBrokerId()))
+                        .add(broker.getName())
+                        .add(String.valueOf(broker.getCredit()));
+                writer.println(joiner);
+            }
+        }
+        log.info("Brokers saved");
+    }
+
+    private void saveShareholdersAndPositions() throws Exception {
+        try (PrintWriter shareholderWriter = new PrintWriter(new FileWriter(shareholderCsvResource.getFile()))) {
+            shareholderWriter.println("shareholderId,name");
+            try (PrintWriter positionWriter = new PrintWriter(new FileWriter(positionCsvResource.getFile()))) {
+                positionWriter.println("shareholderId,isin,positions");
+                for (Shareholder shareholder : shareholderRepository.allShareholders()) {
+                    StringJoiner joiner = new StringJoiner(",");
+                    joiner.add(String.valueOf(shareholder.getShareholderId()))
+                            .add(shareholder.getName());
+                    shareholderWriter.println(joiner);
+                    for (var entry : shareholder.getPositions().entrySet()) {
+                        StringJoiner posJoiner = new StringJoiner(",");
+                        posJoiner.add(String.valueOf(shareholder.getShareholderId()))
+                                .add(entry.getKey().getIsin())
+                                .add(String.valueOf(entry.getValue()));
+                        positionWriter.println(posJoiner);
+                    }
+                }
+            }
+        }
+        log.info("Shareholders and Positions saved");
+    }
+
+    private void saveSecuritiesAndOrderBooks() throws Exception {
+        try (PrintWriter securityWriter = new PrintWriter(new FileWriter(securityCsvResource.getFile()))) {
+            securityWriter.println("isin,tickSize,lotSize");
+            try (PrintWriter orderBookWriter = new PrintWriter(new FileWriter(orderBookCsvResource.getFile()))) {
+                orderBookWriter.println("orderId,isin,side,quantity,price,brokerId,shareholderId,entryTime,status,peakSize,displayedQuantity");
+                for (Security security : securityRepository.allSecurities()) {
+                    StringJoiner joiner = new StringJoiner(",");
+                    joiner.add(security.getIsin())
+                            .add(String.valueOf(security.getTickSize()))
+                            .add(String.valueOf(security.getLotSize()));
+                    securityWriter.println(joiner);
+                    for (Order order : security.getOrderBook().getBuyQueue())
+                        orderBookWriter.println(getCSVString(order));
+                    for (Order order : security.getOrderBook().getSellQueue())
+                        orderBookWriter.println(getCSVString(order));
+                }
+            }
+        }
+        log.info("Securities and OrderBook saved");
+    }
+
+    private static String getCSVString(Order order) {
+        StringJoiner orderJoiner = new StringJoiner(",");
+        orderJoiner.add(String.valueOf(order.getOrderId()))
+                .add(order.getSecurity().getIsin())
+                .add(order.getSide().toString())
+                .add(String.valueOf(order.getQuantity()))
+                .add(String.valueOf(order.getPrice()))
+                .add(String.valueOf(order.getBroker().getBrokerId()))
+                .add(String.valueOf(order.getShareholder().getShareholderId()))
+                .add(order.getEntryTime().toString());
+        if (order instanceof IcebergOrder icebergOrder) {
+            orderJoiner.add(String.valueOf(icebergOrder.getPeakSize()))
+                    .add(String.valueOf(icebergOrder.getDisplayedQuantity()));
+        } else {
+            orderJoiner.add("0").add("0");
+        }
+        return orderJoiner.toString();
+    }
+
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/repository/SecurityRepository.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/repository/SecurityRepository.java
new file mode 100644
index 0000000..75357ae
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/repository/SecurityRepository.java
@@ -0,0 +1,26 @@
+package ir.ramtung.tinyme.repository;
+
+import ir.ramtung.tinyme.domain.entity.Security;
+import org.springframework.stereotype.Component;
+
+import java.util.HashMap;
+
+@Component
+public class SecurityRepository {
+    private final HashMap<String, Security> securityByIsin = new HashMap<>();
+    public Security findSecurityByIsin(String isin) {
+        return securityByIsin.get(isin);
+    }
+
+    public void addSecurity(Security security) {
+        securityByIsin.put(security.getIsin(), security);
+    }
+
+    public void clear() {
+        securityByIsin.clear();
+    }
+
+    Iterable<? extends Security> allSecurities() {
+        return securityByIsin.values();
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/repository/ShareholderRepository.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/repository/ShareholderRepository.java
new file mode 100644
index 0000000..50604d9
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/java/ir/ramtung/tinyme/repository/ShareholderRepository.java
@@ -0,0 +1,25 @@
+package ir.ramtung.tinyme.repository;
+
+import ir.ramtung.tinyme.domain.entity.Shareholder;
+import org.springframework.stereotype.Component;
+
+import java.util.HashMap;
+
+@Component
+public class ShareholderRepository {
+    private final HashMap<Long, Shareholder> shareholderById = new HashMap<>();
+    public Shareholder findShareholderById(long shareholderId) {
+        return shareholderById.get(shareholderId);
+    }
+    public void addShareholder(Shareholder shareholder) {
+        shareholderById.put(shareholder.getShareholderId(), shareholder);
+    }
+
+    public void clear() {
+        shareholderById.clear();
+    }
+
+    Iterable<? extends Shareholder> allShareholders() {
+        return shareholderById.values();
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/resources/application.properties b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/resources/application.properties
new file mode 100644
index 0000000..19ca007
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/resources/application.properties
@@ -0,0 +1,4 @@
+spring.artemis.mode=native
+spring.artemis.broker-url=tcp://127.0.0.1:61616
+requestQueue=RQ
+responseQueue=RS
\ No newline at end of file
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/resources/persistence/broker.csv b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/resources/persistence/broker.csv
new file mode 100644
index 0000000..774fc4f
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/resources/persistence/broker.csv
@@ -0,0 +1,4 @@
+brokerId,name,credit
+1,broker1,100000000
+2,broker2,100000000
+3,broker3,100000000
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/resources/persistence/orderbook.csv b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/resources/persistence/orderbook.csv
new file mode 100644
index 0000000..0b49a6c
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/resources/persistence/orderbook.csv
@@ -0,0 +1,16 @@
+orderId,isin,side,initialQuantity,quantity,price,brokerId,shareholderId,entryTime,peakSize,displayedQuantity,minimumExecutionQuantity
+1,SEC1,BUY,400,304,15700,1,1,2024-02-23T10:59:54.970,0,0,0
+2,SEC1,BUY,100,43,15500,1,2,2024-02-23T10:59:55.970,0,0,0
+3,SEC1,BUY,500,445,15450,1,2,2024-02-23T10:59:56.970,0,0,0
+4,SEC1,BUY,600,526,15450,1,2,2024-02-23T10:59:57.970,0,0,0
+5,SEC1,BUY,1000,1000,15400,1,1,2024-02-23T10:59:58.970,0,0,0
+6,SEC1,SELL,400,350,15800,2,3,2024-02-23T10:59:54.980,0,0,0
+7,SEC1,SELL,300,285,15810,2,3,2024-02-23T10:59:55.980,0,0,0
+8,SEC1,SELL,800,800,15810,3,4,2024-02-23T10:59:56.980,0,0,0
+9,SEC1,SELL,400,340,15820,3,4,2024-02-23T10:59:57.980,0,0,0
+10,SEC1,SELL,100,65,15820,2,3,2024-02-23T10:59:58.980,0,0,0
+11,SEC2,BUY,400,304,15700,1,1,2024-02-23T11:09:10.012,0,0,0
+12,SEC2,BUY,100,43,15500,2,1,2024-02-23T10:00:10.012,0,0,0
+13,SEC2,BUY,500,445,15450,2,2,2024-02-23T11:06:10.012,100,100,0
+14,SEC2,BUY,600,526,15450,3,3,2024-02-23T11:06:11.012,0,0,0
+15,SEC2,BUY,1000,1000,15400,3,1,2024-02-23T11:06:12.012,0,0,0
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/resources/persistence/position.csv b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/resources/persistence/position.csv
new file mode 100644
index 0000000..87bb219
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/resources/persistence/position.csv
@@ -0,0 +1,7 @@
+shareholderId,isin,positions
+1,SEC1,1000
+1,SEC2,800
+2,SEC1,100
+3,SEC1,1000
+3,SEC2,1200
+3,SEC3,2000
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/resources/persistence/security.csv b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/resources/persistence/security.csv
new file mode 100644
index 0000000..1eaa4af
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/resources/persistence/security.csv
@@ -0,0 +1,4 @@
+isin,tickSize,lotSize
+SEC1,1,1
+SEC2,1,1
+SEC3,1,1
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/resources/persistence/shareholder.csv b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/resources/persistence/shareholder.csv
new file mode 100644
index 0000000..1d51a21
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/main/resources/persistence/shareholder.csv
@@ -0,0 +1,5 @@
+shareholderId,name
+1,shareholder1
+2,shareholder2
+3,shareholder3
+4,shareholder4
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/config/MockedJMSTestConfig.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/config/MockedJMSTestConfig.java
new file mode 100644
index 0000000..5fe0db1
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/config/MockedJMSTestConfig.java
@@ -0,0 +1,15 @@
+package ir.ramtung.tinyme.config;
+
+import ir.ramtung.tinyme.messaging.EventPublisher;
+import ir.ramtung.tinyme.messaging.RequestDispatcher;
+import ir.ramtung.tinyme.repository.DataLoader;
+import org.springframework.boot.test.context.TestConfiguration;
+import org.springframework.boot.test.mock.mockito.MockBean;
+
+@TestConfiguration
+public class MockedJMSTestConfig {
+    @MockBean
+    EventPublisher eventPublisher;
+    @MockBean
+    RequestDispatcher requestDispatcher;
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/domain/MatcherTest.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/domain/MatcherTest.java
new file mode 100644
index 0000000..e21498e
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/domain/MatcherTest.java
@@ -0,0 +1,155 @@
+package ir.ramtung.tinyme.domain;
+
+import ir.ramtung.tinyme.config.MockedJMSTestConfig;
+import ir.ramtung.tinyme.domain.entity.*;
+import ir.ramtung.tinyme.domain.service.MatchResult;
+import ir.ramtung.tinyme.domain.service.Matcher;
+import ir.ramtung.tinyme.domain.service.MatchingOutcome;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.boot.test.context.SpringBootTest;
+import org.springframework.context.annotation.Import;
+import org.springframework.test.annotation.DirtiesContext;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static ir.ramtung.tinyme.domain.entity.Side.BUY;
+import static org.assertj.core.api.Assertions.assertThat;
+
+@SpringBootTest
+@Import(MockedJMSTestConfig.class)
+@DirtiesContext
+public class MatcherTest {
+    private Security security;
+    private Broker broker;
+    private Shareholder shareholder;
+    private OrderBook orderBook;
+    private List<Order> orders;
+    @Autowired
+    private Matcher matcher;
+
+    @BeforeEach
+    void setupOrderBook() {
+        security = Security.builder().build();
+        broker = Broker.builder().credit(100_000_000L).build();
+        shareholder = Shareholder.builder().build();
+        shareholder.incPosition(security, 100_000);
+        orderBook = security.getOrderBook();
+        orders = Arrays.asList(
+                new Order(1, security, BUY, 304, 15700, broker, shareholder),
+                new Order(2, security, BUY, 43, 15500, broker, shareholder),
+                new Order(3, security, BUY, 445, 15450, broker, shareholder),
+                new Order(4, security, BUY, 526, 15450, broker, shareholder),
+                new Order(5, security, BUY, 1000, 15400, broker, shareholder),
+                new Order(6, security, Side.SELL, 350, 15800, broker, shareholder),
+                new Order(7, security, Side.SELL, 285, 15810, broker, shareholder),
+                new Order(8, security, Side.SELL, 800, 15810, broker, shareholder),
+                new Order(9, security, Side.SELL, 340, 15820, broker, shareholder),
+                new Order(10, security, Side.SELL, 65, 15820, broker, shareholder)
+        );
+        orders.forEach(order -> orderBook.enqueue(order));
+    }
+
+    @Test
+    void new_sell_order_matches_completely_with_part_of_the_first_buy() {
+        Order order = new Order(11, security, Side.SELL, 100, 15600, broker, shareholder);
+        Trade trade = new Trade(security, 15700, 100, orders.get(0), order);
+        MatchResult result = matcher.match(order);
+        assertThat(result.remainder().getQuantity()).isEqualTo(0);
+        assertThat(result.trades()).containsExactly(trade);
+        assertThat(security.getOrderBook().getBuyQueue().getFirst().getQuantity()).isEqualTo(204);
+    }
+
+    @Test
+    void new_sell_order_matches_partially_with_the_first_buy() {
+        Order order = new Order(11, security, Side.SELL, 500, 15600, broker, shareholder);
+        Trade trade = new Trade(security, 15700, 304, orders.get(0), order);
+        MatchResult result = matcher.match(order);
+        assertThat(result.remainder().getQuantity()).isEqualTo(196);
+        assertThat(result.trades()).containsExactly(trade);
+        assertThat(security.getOrderBook().getBuyQueue().getFirst().getOrderId()).isEqualTo(2);
+    }
+
+    @Test
+    void new_sell_order_matches_partially_with_two_buys() {
+        Order order = new Order(11, security, Side.SELL, 500, 15500, broker, shareholder);
+        Trade trade1 = new Trade(security, 15700, 304, orders.get(0), order);
+        Trade trade2 = new Trade(security, 15500, 43, orders.get(1), order.snapshotWithQuantity(196));
+        MatchResult result = matcher.match(order);
+        assertThat(result.remainder().getQuantity()).isEqualTo(153);
+        assertThat(result.trades()).containsExactly(trade1, trade2);
+        assertThat(security.getOrderBook().getBuyQueue().getFirst().getOrderId()).isEqualTo(3);
+    }
+
+    @Test
+    void new_buy_order_matches_partially_with_the_entire_sell_queue() {
+        Order order = new Order(11, security, BUY, 2000, 15820, broker, shareholder);
+        List<Trade> trades = new ArrayList<>();
+        int totalTraded = 0;
+        for (Order o : orders.subList(5, 10)) {
+            trades.add(new Trade(security, o.getPrice(), o.getQuantity(),
+                    order.snapshotWithQuantity(order.getQuantity() - totalTraded), o));
+            totalTraded += o.getQuantity();
+        }
+
+        MatchResult result = matcher.match(order);
+        assertThat(result.remainder().getQuantity()).isEqualTo(160);
+        assertThat(result.trades()).isEqualTo(trades);
+        assertThat(security.getOrderBook().getSellQueue()).isEmpty();
+    }
+
+    @Test
+    void new_buy_order_does_not_match() {
+        Order order = new Order(11, security, BUY, 2000, 15500, broker, shareholder);
+        MatchResult result = matcher.match(order);
+        assertThat(result.remainder()).isEqualTo(order);
+        assertThat(result.trades()).isEmpty();
+    }
+
+    @Test
+    void iceberg_order_in_queue_matched_completely_after_three_rounds() {
+        security = Security.builder().build();
+        broker = Broker.builder().build();
+        orderBook = security.getOrderBook();
+        orders = Arrays.asList(
+                new IcebergOrder(1, security, BUY, 450, 15450, broker, shareholder, 200),
+                new Order(2, security, BUY, 70, 15450, broker, shareholder),
+                new Order(3, security, BUY, 1000, 15400, broker, shareholder)
+        );
+        orders.forEach(order -> orderBook.enqueue(order));
+        Order order = new Order(4, security, Side.SELL, 600, 15450, broker, shareholder);
+        List<Trade> trades = List.of(
+                new Trade(security, 15450, 200, orders.get(0).snapshotWithQuantity(200), order.snapshotWithQuantity(600)),
+                new Trade(security, 15450, 70, orders.get(1).snapshotWithQuantity(70), order.snapshotWithQuantity(400)),
+                new Trade(security, 15450, 200, orders.get(0).snapshotWithQuantity(200), order.snapshotWithQuantity(330)),
+                new Trade(security, 15450, 50, orders.get(0).snapshotWithQuantity(50), order.snapshotWithQuantity(130))
+        );
+
+        MatchResult result = matcher.match(order);
+
+        assertThat(result.remainder().getQuantity()).isEqualTo(80);
+        assertThat(result.trades()).isEqualTo(trades);
+    }
+
+    @Test
+    void insert_iceberg_and_match_until_quantity_is_less_than_peak_size() {
+        security = Security.builder().isin("TEST").build();
+        shareholder.incPosition(security, 1_000);
+        security.getOrderBook().enqueue(
+                new Order(1, security, Side.SELL, 100, 10, broker, shareholder)
+        );
+
+        Order order = new IcebergOrder(1, security, BUY, 120 , 10, broker, shareholder, 40 );
+        MatchResult result = matcher.execute(order);
+
+        assertThat(result.outcome()).isEqualTo(MatchingOutcome.OK);
+        assertThat(result.trades()).hasSize(1);
+        assertThat(security.getOrderBook().getSellQueue()).hasSize(0);
+        assertThat(security.getOrderBook().getBuyQueue()).hasSize(1);
+        assertThat(security.getOrderBook().getBuyQueue().get(0).getQuantity()).isEqualTo(20);
+
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/domain/MatchingTest.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/domain/MatchingTest.java
new file mode 100644
index 0000000..11e1044
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/domain/MatchingTest.java
@@ -0,0 +1,99 @@
+package ir.ramtung.tinyme.domain;
+
+import ir.ramtung.tinyme.config.MockedJMSTestConfig;
+import ir.ramtung.tinyme.domain.entity.*;
+import ir.ramtung.tinyme.domain.service.MatchResult;
+import ir.ramtung.tinyme.domain.service.Matcher;
+import ir.ramtung.tinyme.utils.FixtureDefaults;
+import ir.ramtung.tinyme.utils.TestOrderBuilder;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.boot.test.context.SpringBootTest;
+import org.springframework.context.annotation.Import;
+
+import static ir.ramtung.tinyme.domain.service.MatchingOutcome.OK;
+import static ir.ramtung.tinyme.domain.service.MatchingOutcome.MINIMUM_QUANTITY_NOT_SATISFIED;
+import static org.assertj.core.api.Assertions.assertThat;
+
+@SpringBootTest
+@Import(MockedJMSTestConfig.class)
+//this class will probably merge with MatcherTest but for introducing new style for utils it is seperated.
+public class MatchingTest {
+
+    @Autowired
+    private Matcher matcher;
+
+    @Autowired
+    private TestOrderBuilder orderBuilder;
+
+    @Autowired
+    private FixtureDefaults fixture;
+
+    private Security security;
+
+    @BeforeEach
+    public void setUp() {
+        fixture.init();
+        security = fixture.getSecurity();
+        security.getOrderBook().enqueue(
+                orderBuilder.createOrder()
+                        .price(101)
+                        .side(Side.BUY)
+                        .quantity(70)
+                        .build()
+        );
+    }
+
+    @AfterEach
+    public void teardown() {
+        fixture.flush();
+    }
+
+    @Test
+    void order_successfully_match_when_MEQ_is_satisfied() {
+        Order newOrder = orderBuilder.createOrder()
+                .side(Side.SELL)
+                .quantity(100)
+                .minimumExecutionQuantity(50)
+                .build();
+
+        MatchResult result = matcher.execute(newOrder);
+
+        assertThat(result.outcome()).isEqualTo(OK);
+        assertThat(result.trades()).hasSize(1);
+        assertThat(result.remainder().getQuantity()).isEqualTo(30);
+    }
+
+    @Test
+    void order_not_matched_when_MEQ_is_not_satisfied() {
+        Order newOrder = orderBuilder.createOrder()
+                .side(Side.SELL)
+                .quantity(200)
+                .minimumExecutionQuantity(100)
+                .build();
+
+        MatchResult result = matcher.execute(newOrder);
+
+        assertThat(result.outcome()).isEqualTo(MINIMUM_QUANTITY_NOT_SATISFIED);
+        assertThat(result.trades()).hasSize(0);
+    }
+
+    @Test
+    void MEQ_works_with_iceberg_order() {
+        IcebergOrder newOrder = (IcebergOrder) orderBuilder.createIcebergOrder()
+                .side(Side.SELL)
+                .quantity(100, 20)
+                .minimumExecutionQuantity(50)
+                .build();
+
+        MatchResult result = matcher.execute(newOrder);
+
+        assertThat(result.outcome()).isEqualTo(OK);
+        assertThat(result.trades()).hasSize(1);
+        assertThat(result.remainder().getQuantity()).isEqualTo(20);
+    }
+
+
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/domain/OrderBookTest.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/domain/OrderBookTest.java
new file mode 100644
index 0000000..576c60d
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/domain/OrderBookTest.java
@@ -0,0 +1,79 @@
+package ir.ramtung.tinyme.domain;
+
+import ir.ramtung.tinyme.domain.entity.*;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import java.util.Arrays;
+import java.util.List;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+class OrderBookTest {
+    private Security security;
+    private List<Order> orders;
+    @BeforeEach
+    void setupOrderBook() {
+        security = Security.builder().build();
+        Broker broker = Broker.builder().build();
+        Shareholder shareholder = Shareholder.builder().build();
+        shareholder.incPosition(security, 100_000);
+        orders = Arrays.asList(
+                new Order(1, security, Side.BUY, 304, 15700, broker, shareholder),
+                new Order(2, security, Side.BUY, 43, 15500, broker, shareholder),
+                new Order(3, security, Side.BUY, 445, 15450, broker, shareholder),
+                new Order(4, security, Side.BUY, 526, 15450, broker, shareholder),
+                new Order(5, security, Side.BUY, 1000, 15400, broker, shareholder),
+                new Order(6, security, Side.SELL, 350, 15800, broker, shareholder),
+                new Order(7, security, Side.SELL, 285, 15810, broker, shareholder),
+                new Order(8, security, Side.SELL, 800, 15810, broker, shareholder),
+                new Order(9, security, Side.SELL, 340, 15820, broker, shareholder),
+                new Order(10, security, Side.SELL, 65, 15820, broker, shareholder)
+        );
+        orders.forEach(order -> security.getOrderBook().enqueue(order));
+    }
+
+    @Test
+    void finds_the_first_order_by_id() {
+        assertThat(security.getOrderBook().findByOrderId(Side.BUY, 1))
+                .isEqualTo(orders.get(0));
+    }
+
+    @Test
+    void fails_to_find_the_first_order_by_id_in_the_wrong_queue() {
+        assertThat(security.getOrderBook().findByOrderId(Side.SELL, 1)).isNull();
+    }
+
+    @Test
+    void finds_some_order_in_the_middle_by_id() {
+        assertThat(security.getOrderBook().findByOrderId(Side.BUY, 3))
+                .isEqualTo(orders.get(2));
+    }
+
+    @Test
+    void finds_the_last_order_by_id() {
+        assertThat(security.getOrderBook().findByOrderId(Side.SELL, 10))
+                .isEqualTo(orders.get(9));
+    }
+
+    @Test
+    void removes_the_first_order_by_id() {
+        OrderBook orderBook = security.getOrderBook();
+        orderBook.removeByOrderId(Side.BUY, 1);
+        assertThat(orderBook.getBuyQueue()).isEqualTo(orders.subList(1, 5));
+    }
+
+    @Test
+    void fails_to_remove_the_first_order_by_id_in_the_wrong_queue() {
+        OrderBook orderBook = security.getOrderBook();
+        orderBook.removeByOrderId(Side.SELL, 1);
+        assertThat(orderBook.getBuyQueue()).isEqualTo(orders.subList(0, 5));
+    }
+
+    @Test
+    void removes_the_last_order_by_id() {
+        OrderBook orderBook = security.getOrderBook();
+        orderBook.removeByOrderId(Side.SELL, 10);
+        assertThat(orderBook.getSellQueue()).isEqualTo(orders.subList(5, 9));
+    }
+}
\ No newline at end of file
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/domain/OrderHandlerCreditCheckRollbackTest.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/domain/OrderHandlerCreditCheckRollbackTest.java
new file mode 100644
index 0000000..d830fe3
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/domain/OrderHandlerCreditCheckRollbackTest.java
@@ -0,0 +1,161 @@
+package ir.ramtung.tinyme.domain;
+
+import ir.ramtung.tinyme.config.MockedJMSTestConfig;
+import ir.ramtung.tinyme.domain.entity.*;
+import ir.ramtung.tinyme.domain.service.OrderHandler;
+import ir.ramtung.tinyme.messaging.EventPublisher;
+import ir.ramtung.tinyme.messaging.Message;
+import ir.ramtung.tinyme.messaging.event.OrderRejectedEvent;
+import ir.ramtung.tinyme.messaging.request.EnterOrderRq;
+import ir.ramtung.tinyme.repository.BrokerRepository;
+import ir.ramtung.tinyme.repository.SecurityRepository;
+import ir.ramtung.tinyme.repository.ShareholderRepository;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.boot.test.context.SpringBootTest;
+import org.springframework.context.annotation.Import;
+import org.springframework.test.annotation.DirtiesContext;
+
+import java.time.LocalDateTime;
+import java.util.Arrays;
+import java.util.List;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.verify;
+
+@SpringBootTest
+@Import(MockedJMSTestConfig.class)
+@DirtiesContext
+public class OrderHandlerCreditCheckRollbackTest {
+    @Autowired
+    OrderHandler orderHandler;
+    @Autowired
+    EventPublisher eventPublisher;
+    @Autowired
+    SecurityRepository securityRepository;
+    @Autowired
+    BrokerRepository brokerRepository;
+    @Autowired
+    ShareholderRepository shareholderRepository;
+    private Security security;
+    private Shareholder shareholder;
+
+    @BeforeEach
+    void setup() {
+        securityRepository.clear();
+        shareholderRepository.clear();
+        brokerRepository.clear();
+
+        security = Security.builder().build();
+        securityRepository.addSecurity(security);
+
+        shareholder = Shareholder.builder().build();
+        shareholderRepository.addShareholder(shareholder);
+        shareholder.incPosition(security, 100_000);
+    }
+    @Test
+    void new_order_from_buyer_with_not_enough_credit_based_on_trades() {
+        Broker broker1 = Broker.builder().brokerId(1).credit(100_000).build();
+        Broker broker2 = Broker.builder().brokerId(2).credit(100_000).build();
+        Broker broker3 = Broker.builder().brokerId(3).credit(50_000).build();
+        brokerRepository.addBroker(broker1);
+        brokerRepository.addBroker(broker2);
+        brokerRepository.addBroker(broker3);
+        OrderBook orderBook = security.getOrderBook();
+        List<Order> orders = Arrays.asList(
+                new Order(100, security, Side.SELL, 30, 500, broker1, shareholder),
+                new Order(110, security, Side.SELL, 20, 500, broker2, shareholder),
+                new Order(120, security, Side.SELL, 20, 600, broker2, shareholder)
+        );
+        orders.forEach(orderBook::enqueue);
+
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createNewOrderRq(1, security.getIsin(), 200, LocalDateTime.now(), Side.BUY, 100, 550, broker3.getBrokerId(), shareholder.getShareholderId(), 0,0));
+
+        assertThat(broker1.getCredit()).isEqualTo(100_000);
+        assertThat(broker2.getCredit()).isEqualTo(100_000);
+        assertThat(broker3.getCredit()).isEqualTo(50_000);
+
+        assertThat(orderBook.getBuyQueue()).isEmpty();
+        assertThat(orderBook.getSellQueue()).extracting("orderId")
+                .containsExactly(100L, 110L, 120L);
+        assertThat(orderBook.getSellQueue()).extracting("quantity")
+                .containsExactly(30, 20, 20);
+        assertThat(orderBook.getSellQueue()).extracting("price")
+                .containsExactly(500, 500, 600);
+
+        verify(eventPublisher).publish(new OrderRejectedEvent(1, 200, List.of(Message.BUYER_HAS_NOT_ENOUGH_CREDIT)));
+    }
+
+    @Test
+    void new_order_from_buyer_with_not_enough_credit_based_on_trades_with_iceberg_orders() {
+        Broker broker1 = Broker.builder().brokerId(1).credit(100_000).build();
+        Broker broker2 = Broker.builder().brokerId(2).credit(100_000).build();
+        Broker broker3 = Broker.builder().brokerId(3).credit(92_650).build();
+        brokerRepository.addBroker(broker1);
+        brokerRepository.addBroker(broker2);
+        brokerRepository.addBroker(broker3);
+        OrderBook orderBook = security.getOrderBook();
+        List<Order> orders = Arrays.asList(
+                new IcebergOrder(1, security, Side.SELL, 45, 1545, broker1, shareholder, 200),
+                new Order(2, security, Side.SELL, 7, 1545, broker2, shareholder),
+                new Order(3, security, Side.SELL, 10, 1550, broker2, shareholder)
+        );
+        orders.forEach(orderBook::enqueue);
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createNewOrderRq(1, security.getIsin(), 200, LocalDateTime.now(),
+                Side.BUY, 60, 1545, broker3.getBrokerId(), shareholder.getShareholderId(), 0,0));
+
+        assertThat(broker1.getCredit()).isEqualTo(100_000);
+        assertThat(broker2.getCredit()).isEqualTo(100_000);
+        assertThat(broker3.getCredit()).isEqualTo(92_650);
+
+        assertThat(orderBook.getBuyQueue()).isEmpty();
+        assertThat(orderBook.getSellQueue()).extracting("orderId")
+                .containsExactly(1L, 2L, 3L);
+        assertThat(orderBook.getSellQueue()).extracting("quantity")
+                .containsExactly(45, 7, 10);
+        assertThat(orderBook.getSellQueue()).extracting("price")
+                .containsExactly(1545, 1545, 1550);
+
+        verify(eventPublisher).publish(new OrderRejectedEvent(1, 200, List.of(Message.BUYER_HAS_NOT_ENOUGH_CREDIT)));
+    }
+
+    @Test
+    void update_order_from_buyer_with_not_enough_credit_based_on_trades_with_iceberg_orders() {
+        Broker broker1 = Broker.builder().brokerId(1).credit(100_000).build();
+        Broker broker2 = Broker.builder().brokerId(2).credit(100_000).build();
+        Broker broker3 = Broker.builder().brokerId(3).credit(100).build();
+        brokerRepository.addBroker(broker1);
+        brokerRepository.addBroker(broker2);
+        brokerRepository.addBroker(broker3);
+        OrderBook orderBook = security.getOrderBook();
+        List<Order> orders = Arrays.asList(
+                new IcebergOrder(1, security, Side.SELL, 45, 1545, broker1, shareholder, 200),
+                new Order(2, security, Side.SELL, 7, 1545, broker2, shareholder),
+                new Order(3, security, Side.SELL, 10, 1550, broker2, shareholder),
+                new Order(4, security, Side.BUY, 60, 1540, broker3, shareholder)
+        );
+        orders.forEach(orderBook::enqueue);
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createUpdateOrderRq(1, security.getIsin(), 4, LocalDateTime.now(),
+                Side.BUY, 60, 1545, broker3.getBrokerId(), shareholder.getShareholderId(), 0));
+
+        assertThat(broker1.getCredit()).isEqualTo(100_000);
+        assertThat(broker2.getCredit()).isEqualTo(100_000);
+        assertThat(broker3.getCredit()).isEqualTo(100);
+
+        assertThat(orderBook.getBuyQueue().size()).isEqualTo(1);
+        assertThat(orderBook.getBuyQueue().get(0)).extracting("orderId", "quantity", "price")
+                .containsExactly(4L, 60, 1540);
+        assertThat(orderBook.getSellQueue()).extracting("orderId")
+                .containsExactly(1L, 2L, 3L);
+        assertThat(orderBook.getSellQueue()).extracting("quantity")
+                .containsExactly(45, 7, 10);
+        assertThat(orderBook.getSellQueue()).extracting("price")
+                .containsExactly(1545, 1545, 1550);
+
+        verify(eventPublisher).publish(new OrderRejectedEvent(1, 4, List.of(Message.BUYER_HAS_NOT_ENOUGH_CREDIT)));
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/domain/OrderHandlerTest.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/domain/OrderHandlerTest.java
new file mode 100644
index 0000000..1eb1f8b
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/domain/OrderHandlerTest.java
@@ -0,0 +1,560 @@
+package ir.ramtung.tinyme.domain;
+
+import ir.ramtung.tinyme.config.MockedJMSTestConfig;
+import ir.ramtung.tinyme.domain.entity.*;
+import ir.ramtung.tinyme.domain.service.OrderHandler;
+import ir.ramtung.tinyme.messaging.EventPublisher;
+import ir.ramtung.tinyme.messaging.Message;
+import ir.ramtung.tinyme.messaging.TradeDTO;
+import ir.ramtung.tinyme.messaging.event.*;
+import ir.ramtung.tinyme.messaging.request.DeleteOrderRq;
+import ir.ramtung.tinyme.messaging.request.EnterOrderRq;
+import ir.ramtung.tinyme.repository.BrokerRepository;
+import ir.ramtung.tinyme.repository.SecurityRepository;
+import ir.ramtung.tinyme.repository.ShareholderRepository;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.mockito.ArgumentCaptor;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.boot.test.context.SpringBootTest;
+import org.springframework.context.annotation.Import;
+import org.springframework.test.annotation.DirtiesContext;
+
+import java.time.LocalDateTime;
+import java.util.Arrays;
+import java.util.List;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.*;
+
+@SpringBootTest
+@Import(MockedJMSTestConfig.class)
+@DirtiesContext
+public class OrderHandlerTest {
+    @Autowired
+    OrderHandler orderHandler;
+    @Autowired
+    EventPublisher eventPublisher;
+    @Autowired
+    SecurityRepository securityRepository;
+    @Autowired
+    BrokerRepository brokerRepository;
+    @Autowired
+    ShareholderRepository shareholderRepository;
+    private Security security;
+    private Shareholder shareholder;
+    private Broker broker1;
+    private Broker broker2;
+    private Broker broker3;
+
+    @BeforeEach
+    void setup() {
+        securityRepository.clear();
+        brokerRepository.clear();
+        shareholderRepository.clear();
+
+        security = Security.builder().isin("ABC").build();
+        securityRepository.addSecurity(security);
+
+        shareholder = Shareholder.builder().build();
+        shareholder.incPosition(security, 100_000);
+        shareholderRepository.addShareholder(shareholder);
+
+        broker1 = Broker.builder().brokerId(1).build();
+        broker2 = Broker.builder().brokerId(2).build();
+        broker3 = Broker.builder().brokerId(2).build();
+        brokerRepository.addBroker(broker1);
+        brokerRepository.addBroker(broker2);
+        brokerRepository.addBroker(broker3);
+    }
+    @Test
+    void new_order_matched_completely_with_one_trade() {
+        Order matchingBuyOrder = new Order(100, security, Side.BUY, 1000, 15500, broker1, shareholder);
+        Order incomingSellOrder = new Order(200, security, Side.SELL, 300, 15450, broker2, shareholder);
+        security.getOrderBook().enqueue(matchingBuyOrder);
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createNewOrderRq(1, "ABC", 200, LocalDateTime.now(), Side.SELL, 300, 15450, 2, shareholder.getShareholderId(), 0,0));
+
+        Trade trade = new Trade(security, matchingBuyOrder.getPrice(), incomingSellOrder.getQuantity(),
+                matchingBuyOrder, incomingSellOrder);
+        verify(eventPublisher).publish((new OrderAcceptedEvent(1, 200)));
+        verify(eventPublisher).publish(new OrderExecutedEvent(1, 200, List.of(new TradeDTO(trade))));
+    }
+
+    @Test
+    void new_order_queued_with_no_trade() {
+        orderHandler.handleEnterOrder(EnterOrderRq.createNewOrderRq(1, "ABC", 200, LocalDateTime.now(), Side.SELL, 300, 15450, 2, shareholder.getShareholderId(), 0,0));
+        verify(eventPublisher).publish(new OrderAcceptedEvent(1, 200));
+    }
+    @Test
+    void new_order_matched_partially_with_two_trades() {
+        Order matchingBuyOrder1 = new Order(100, security, Side.BUY, 300, 15500, broker1, shareholder);
+        Order matchingBuyOrder2 = new Order(110, security, Side.BUY, 300, 15500, broker1, shareholder);
+        Order incomingSellOrder = new Order(200, security, Side.SELL, 1000, 15450, broker2, shareholder);
+        security.getOrderBook().enqueue(matchingBuyOrder1);
+        security.getOrderBook().enqueue(matchingBuyOrder2);
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createNewOrderRq(1,
+                incomingSellOrder.getSecurity().getIsin(),
+                incomingSellOrder.getOrderId(),
+                incomingSellOrder.getEntryTime(),
+                incomingSellOrder.getSide(),
+                incomingSellOrder.getTotalQuantity(),
+                incomingSellOrder.getPrice(),
+                incomingSellOrder.getBroker().getBrokerId(),
+                incomingSellOrder.getShareholder().getShareholderId(), 0,0));
+
+        Trade trade1 = new Trade(security, matchingBuyOrder1.getPrice(), matchingBuyOrder1.getQuantity(),
+                matchingBuyOrder1, incomingSellOrder);
+        Trade trade2 = new Trade(security, matchingBuyOrder2.getPrice(), matchingBuyOrder2.getQuantity(),
+                matchingBuyOrder2, incomingSellOrder.snapshotWithQuantity(700));
+        verify(eventPublisher).publish(new OrderAcceptedEvent(1, 200));
+        verify(eventPublisher).publish(new OrderExecutedEvent(1, 200, List.of(new TradeDTO(trade1), new TradeDTO(trade2))));
+    }
+
+    @Test
+    void iceberg_order_behaves_normally_before_being_queued() {
+        Order matchingBuyOrder = new Order(100, security, Side.BUY, 1000, 15500, broker1, shareholder);
+        Order incomingSellOrder = new IcebergOrder(200, security, Side.SELL, 300, 15450, broker2, shareholder, 100);
+        security.getOrderBook().enqueue(matchingBuyOrder);
+        Trade trade = new Trade(security, matchingBuyOrder.getPrice(), incomingSellOrder.getQuantity(),
+                matchingBuyOrder, incomingSellOrder);
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createNewOrderRq(1,
+                incomingSellOrder.getSecurity().getIsin(),
+                incomingSellOrder.getOrderId(),
+                incomingSellOrder.getEntryTime(),
+                incomingSellOrder.getSide(),
+                incomingSellOrder.getTotalQuantity(),
+                incomingSellOrder.getPrice(),
+                incomingSellOrder.getBroker().getBrokerId(),
+                incomingSellOrder.getShareholder().getShareholderId(), 100,0));
+
+        verify(eventPublisher).publish(new OrderAcceptedEvent(1, 200));
+        verify(eventPublisher).publish(new OrderExecutedEvent(1, 200, List.of(new TradeDTO(trade))));
+    }
+
+    @Test
+    void invalid_new_order_with_multiple_errors() {
+        orderHandler.handleEnterOrder(EnterOrderRq.createNewOrderRq(1, "XXX", -1, LocalDateTime.now(), Side.SELL, 0, 0, -1, -1, 0,0));
+        ArgumentCaptor<OrderRejectedEvent> orderRejectedCaptor = ArgumentCaptor.forClass(OrderRejectedEvent.class);
+        verify(eventPublisher).publish(orderRejectedCaptor.capture());
+        OrderRejectedEvent outputEvent = orderRejectedCaptor.getValue();
+        assertThat(outputEvent.getOrderId()).isEqualTo(-1);
+        assertThat(outputEvent.getErrors()).containsOnly(
+                Message.UNKNOWN_SECURITY_ISIN,
+                Message.INVALID_ORDER_ID,
+                Message.ORDER_PRICE_NOT_POSITIVE,
+                Message.ORDER_QUANTITY_NOT_POSITIVE,
+                Message.INVALID_PEAK_SIZE,
+                Message.UNKNOWN_BROKER_ID,
+                Message.UNKNOWN_SHAREHOLDER_ID
+        );
+    }
+
+    @Test
+    void invalid_new_order_with_tick_and_lot_size_errors() {
+        Security aSecurity = Security.builder().isin("XXX").lotSize(10).tickSize(10).build();
+        securityRepository.addSecurity(aSecurity);
+        orderHandler.handleEnterOrder(EnterOrderRq.createNewOrderRq(1, "XXX", 1, LocalDateTime.now(), Side.SELL, 12, 1001, 1, shareholder.getShareholderId(), 0,0));
+        ArgumentCaptor<OrderRejectedEvent> orderRejectedCaptor = ArgumentCaptor.forClass(OrderRejectedEvent.class);
+        verify(eventPublisher).publish(orderRejectedCaptor.capture());
+        OrderRejectedEvent outputEvent = orderRejectedCaptor.getValue();
+        assertThat(outputEvent.getOrderId()).isEqualTo(1);
+        assertThat(outputEvent.getErrors()).containsOnly(
+                Message.QUANTITY_NOT_MULTIPLE_OF_LOT_SIZE,
+                Message.PRICE_NOT_MULTIPLE_OF_TICK_SIZE
+        );
+    }
+
+    @Test
+    void update_order_causing_no_trades() {
+        Order queuedOrder = new Order(200, security, Side.SELL, 500, 15450, broker1, shareholder);
+        security.getOrderBook().enqueue(queuedOrder);
+        orderHandler.handleEnterOrder(EnterOrderRq.createUpdateOrderRq(1, "ABC", 200, LocalDateTime.now(), Side.SELL, 1000, 15450, 1, shareholder.getShareholderId(), 0));
+        verify(eventPublisher).publish(new OrderUpdatedEvent(1, 200));
+    }
+
+    @Test
+    void handle_valid_update_with_trades() {
+        Order matchingOrder = new Order(1, security, Side.BUY, 500, 15450, broker1, shareholder);
+        Order beforeUpdate = new Order(200, security, Side.SELL, 1000, 15455, broker2, shareholder);
+        Order afterUpdate = new Order(200, security, Side.SELL, 500, 15450, broker2, shareholder);
+        security.getOrderBook().enqueue(matchingOrder);
+        security.getOrderBook().enqueue(beforeUpdate);
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createUpdateOrderRq(1, "ABC", 200, LocalDateTime.now(), Side.SELL, 1000, 15450, broker2.getBrokerId(), shareholder.getShareholderId(), 0));
+
+        Trade trade = new Trade(security, 15450, 500, matchingOrder, afterUpdate);
+        verify(eventPublisher).publish(new OrderUpdatedEvent(1, 200));
+        verify(eventPublisher).publish(new OrderExecutedEvent(1, 200, List.of(new TradeDTO(trade))));
+    }
+
+    @Test
+    void invalid_update_with_order_id_not_found() {
+        orderHandler.handleEnterOrder(EnterOrderRq.createUpdateOrderRq(1, "ABC", 200, LocalDateTime.now(), Side.SELL, 1000, 15450, 1, shareholder.getShareholderId(), 0));
+        verify(eventPublisher).publish(new OrderRejectedEvent(1, 200, any()));
+    }
+
+    @Test
+    void invalid_update_with_multiple_errors() {
+        orderHandler.handleEnterOrder(EnterOrderRq.createUpdateOrderRq(1, "XXX", -1, LocalDateTime.now(), Side.SELL, 0, 0, -1, shareholder.getShareholderId(), 0));
+        ArgumentCaptor<OrderRejectedEvent> orderRejectedCaptor = ArgumentCaptor.forClass(OrderRejectedEvent.class);
+        verify(eventPublisher).publish(orderRejectedCaptor.capture());
+        OrderRejectedEvent outputEvent = orderRejectedCaptor.getValue();
+        assertThat(outputEvent.getOrderId()).isEqualTo(-1);
+        assertThat(outputEvent.getErrors()).containsOnly(
+                Message.UNKNOWN_SECURITY_ISIN,
+                Message.UNKNOWN_BROKER_ID,
+                Message.INVALID_ORDER_ID,
+                Message.ORDER_PRICE_NOT_POSITIVE,
+                Message.ORDER_QUANTITY_NOT_POSITIVE,
+                Message.INVALID_PEAK_SIZE
+        );
+    }
+
+    @Test
+    void delete_buy_order_deletes_successfully_and_increases_credit() {
+        Broker buyBroker = Broker.builder().credit(1_000_000).build();
+        brokerRepository.addBroker(buyBroker);
+        Order someOrder = new Order(100, security, Side.BUY, 300, 15500, buyBroker, shareholder);
+        Order queuedOrder = new Order(200, security, Side.BUY, 1000, 15500, buyBroker, shareholder);
+        security.getOrderBook().enqueue(someOrder);
+        security.getOrderBook().enqueue(queuedOrder);
+        orderHandler.handleDeleteOrder(new DeleteOrderRq(1, security.getIsin(), Side.BUY, 200));
+        verify(eventPublisher).publish(new OrderDeletedEvent(1, 200));
+        assertThat(buyBroker.getCredit()).isEqualTo(1_000_000 + 1000*15500);
+    }
+
+    @Test
+    void delete_sell_order_deletes_successfully_and_does_not_change_credit() {
+        Broker sellBroker = Broker.builder().credit(1_000_000).build();
+        brokerRepository.addBroker(sellBroker);
+        Order someOrder = new Order(100, security, Side.SELL, 300, 15500, sellBroker, shareholder);
+        Order queuedOrder = new Order(200, security, Side.SELL, 1000, 15500, sellBroker, shareholder);
+        security.getOrderBook().enqueue(someOrder);
+        security.getOrderBook().enqueue(queuedOrder);
+        orderHandler.handleDeleteOrder(new DeleteOrderRq(1, security.getIsin(), Side.SELL, 200));
+        verify(eventPublisher).publish(new OrderDeletedEvent(1, 200));
+        assertThat(sellBroker.getCredit()).isEqualTo(1_000_000);
+    }
+
+
+    @Test
+    void invalid_delete_with_order_id_not_found() {
+        Broker buyBroker = Broker.builder().credit(1_000_000).build();
+        brokerRepository.addBroker(buyBroker);
+        Order queuedOrder = new Order(200, security, Side.BUY, 1000, 15500, buyBroker, shareholder);
+        security.getOrderBook().enqueue(queuedOrder);
+        orderHandler.handleDeleteOrder(new DeleteOrderRq(1, "ABC", Side.SELL, 100));
+        verify(eventPublisher).publish(new OrderRejectedEvent(1, 100, List.of(Message.ORDER_ID_NOT_FOUND)));
+        assertThat(buyBroker.getCredit()).isEqualTo(1_000_000);
+    }
+
+    @Test
+    void invalid_delete_order_with_non_existing_security() {
+        Order queuedOrder = new Order(200, security, Side.BUY, 1000, 15500, broker1, shareholder);
+        security.getOrderBook().enqueue(queuedOrder);
+        orderHandler.handleDeleteOrder(new DeleteOrderRq(1, "XXX", Side.SELL, 200));
+        verify(eventPublisher).publish(new OrderRejectedEvent(1, 200, List.of(Message.UNKNOWN_SECURITY_ISIN)));
+    }
+
+    @Test
+    void buyers_credit_decreases_on_new_order_without_trades() {
+        Broker broker = Broker.builder().brokerId(10).credit(10_000).build();
+        brokerRepository.addBroker(broker);
+        orderHandler.handleEnterOrder(EnterOrderRq.createNewOrderRq(1, "ABC", 200, LocalDateTime.now(), Side.BUY, 30, 100, 10, shareholder.getShareholderId(), 0,0));
+        assertThat(broker.getCredit()).isEqualTo(10_000-30*100);
+    }
+
+    @Test
+    void buyers_credit_decreases_on_new_iceberg_order_without_trades() {
+        Broker broker = Broker.builder().brokerId(10).credit(10_000).build();
+        brokerRepository.addBroker(broker);
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createNewOrderRq(1, "ABC", 200, LocalDateTime.now(), Side.BUY, 30, 100, 10, shareholder.getShareholderId(), 10,0));
+        assertThat(broker.getCredit()).isEqualTo(10_000-30*100);
+    }
+
+    @Test
+    void credit_does_not_change_on_invalid_new_order() {
+        Broker broker = Broker.builder().brokerId(10).credit(10_000).build();
+        brokerRepository.addBroker(broker);
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createNewOrderRq(1, "ABC", -1, LocalDateTime.now(), Side.BUY, 30, 100, broker.getBrokerId(), shareholder.getShareholderId(), 0,0));
+        assertThat(broker.getCredit()).isEqualTo(10_000);
+    }
+
+    @Test
+    void credit_updated_on_new_order_matched_partially_with_two_orders() {
+        Broker broker1 = Broker.builder().brokerId(10).credit(100_000).build();
+        Broker broker2 = Broker.builder().brokerId(20).credit(100_000).build();
+        Broker broker3 = Broker.builder().brokerId(30).credit(100_000).build();
+        List.of(broker1, broker2, broker3).forEach(b -> brokerRepository.addBroker(b));
+
+        Order matchingSellOrder1 = new Order(100, security, Side.SELL, 30, 500, broker1, shareholder);
+        Order matchingSellOrder2 = new Order(110, security, Side.SELL, 20, 500, broker2, shareholder);
+        security.getOrderBook().enqueue(matchingSellOrder1);
+        security.getOrderBook().enqueue(matchingSellOrder2);
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createNewOrderRq(1, "ABC", 200, LocalDateTime.now(), Side.BUY, 100, 550, broker3.getBrokerId(), shareholder.getShareholderId(), 0,0));
+
+        assertThat(broker1.getCredit()).isEqualTo(100_000 + 30*500);
+        assertThat(broker2.getCredit()).isEqualTo(100_000 + 20*500);
+        assertThat(broker3.getCredit()).isEqualTo(100_000 - 50*500 - 50*550);
+    }
+
+    @Test
+    void new_order_from_buyer_with_not_enough_credit_no_trades() {
+        Broker broker = Broker.builder().brokerId(10).credit(1000).build();
+        brokerRepository.addBroker(broker);
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createNewOrderRq(1, "ABC", 200, LocalDateTime.now(), Side.BUY, 30, 100, 10, shareholder.getShareholderId(), 0,0));
+        assertThat(broker.getCredit()).isEqualTo(1000);
+        verify(eventPublisher).publish(new OrderRejectedEvent(1, 200, List.of(Message.BUYER_HAS_NOT_ENOUGH_CREDIT)));
+    }
+
+    @Test
+    void new_order_from_buyer_with_enough_credit_based_on_trades() {
+        Broker broker1 = Broker.builder().brokerId(10).credit(100_000).build();
+        Broker broker2 = Broker.builder().brokerId(20).credit(100_000).build();
+        Broker broker3 = Broker.builder().brokerId(30).credit(52_500).build();
+        List.of(broker1, broker2, broker3).forEach(b -> brokerRepository.addBroker(b));
+        Order matchingSellOrder1 = new Order(100, security, Side.SELL, 30, 500, broker1, shareholder);
+        Order matchingSellOrder2 = new Order(110, security, Side.SELL, 20, 500, broker2, shareholder);
+        Order incomingBuyOrder = new Order(200, security, Side.BUY, 100, 550, broker3, shareholder);
+        security.getOrderBook().enqueue(matchingSellOrder1);
+        security.getOrderBook().enqueue(matchingSellOrder2);
+        Trade trade1 = new Trade(security, matchingSellOrder1.getPrice(), matchingSellOrder1.getQuantity(),
+                incomingBuyOrder, matchingSellOrder1);
+        Trade trade2 = new Trade(security, matchingSellOrder2.getPrice(), matchingSellOrder2.getQuantity(),
+                incomingBuyOrder.snapshotWithQuantity(700), matchingSellOrder2);
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createNewOrderRq(1, "ABC", 200, LocalDateTime.now(), Side.BUY, 100, 550, broker3.getBrokerId(), shareholder.getShareholderId(), 0,0));
+
+        assertThat(broker1.getCredit()).isEqualTo(100_000 + 30*500);
+        assertThat(broker2.getCredit()).isEqualTo(100_000 + 20*500);
+        assertThat(broker3.getCredit()).isEqualTo(0);
+
+        verify(eventPublisher).publish(new OrderAcceptedEvent(1, 200));
+        verify(eventPublisher).publish(new OrderExecutedEvent(1, 200, List.of(new TradeDTO(trade1), new TradeDTO(trade2))));
+    }
+
+    @Test
+    void new_order_from_buyer_with_not_enough_credit_based_on_trades() {
+        Broker broker1 = Broker.builder().brokerId(1).credit(100_000).build();
+        Broker broker2 = Broker.builder().brokerId(2).credit(100_000).build();
+        Broker broker3 = Broker.builder().brokerId(3).credit(50_000).build();
+        List.of(broker1, broker2, broker3).forEach(b -> brokerRepository.addBroker(b));
+        Order matchingSellOrder1 = new Order(100, security, Side.SELL, 30, 500, broker1, shareholder);
+        Order matchingSellOrder2 = new Order(110, security, Side.SELL, 20, 500, broker2, shareholder);
+        security.getOrderBook().enqueue(matchingSellOrder1);
+        security.getOrderBook().enqueue(matchingSellOrder2);
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createNewOrderRq(1, "ABC", 200, LocalDateTime.now(), Side.BUY, 100, 550, broker3.getBrokerId(), shareholder.getShareholderId(), 0,0));
+
+        assertThat(broker1.getCredit()).isEqualTo(100_000);
+        assertThat(broker2.getCredit()).isEqualTo(100_000);
+        assertThat(broker3.getCredit()).isEqualTo(50_000);
+
+        verify(eventPublisher).publish(new OrderRejectedEvent(1, 200, List.of(Message.BUYER_HAS_NOT_ENOUGH_CREDIT)));
+    }
+
+    @Test
+    void update_buy_order_changing_price_with_no_trades_changes_buyers_credit() {
+        Broker broker1 = Broker.builder().brokerId(1).credit(100_000).build();
+        brokerRepository.addBroker(broker1);
+        Order order = new Order(100, security, Side.BUY, 30, 500, broker1, shareholder);
+        security.getOrderBook().enqueue(order);
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createUpdateOrderRq(1, "ABC", 100, LocalDateTime.now(), Side.BUY, 30, 550, broker1.getBrokerId(), shareholder.getShareholderId(), 0));
+
+        assertThat(broker1.getCredit()).isEqualTo(100_000 - 1_500);
+    }
+    @Test
+    void update_sell_order_changing_price_with_no_trades_does_not_changes_sellers_credit() {
+        Broker broker1 = Broker.builder().brokerId(1).credit(100_000).build();
+        brokerRepository.addBroker(broker1);
+        Order order = new Order(100, security, Side.SELL, 30, 500, broker1, shareholder);
+        security.getOrderBook().enqueue(order);
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createUpdateOrderRq(1, "ABC", 100, LocalDateTime.now(), Side.SELL, 30, 550, broker1.getBrokerId(), shareholder.getShareholderId(), 0));
+
+        assertThat(broker1.getCredit()).isEqualTo(100_000);
+    }
+
+    @Test
+    void update_order_changing_price_with_trades_changes_buyers_and_sellers_credit() {
+        Broker broker1 = Broker.builder().brokerId(10).credit(100_000).build();
+        Broker broker2 = Broker.builder().brokerId(20).credit(100_000).build();
+        Broker broker3 = Broker.builder().brokerId(30).credit(100_000).build();
+        List.of(broker1, broker2, broker3).forEach(b -> brokerRepository.addBroker(b));
+        List<Order> orders = Arrays.asList(
+                new Order(1, security, Side.BUY, 304, 570, broker3, shareholder),
+                new Order(2, security, Side.BUY, 430, 550, broker3, shareholder),
+                new Order(3, security, Side.BUY, 445, 545, broker3, shareholder),
+                new Order(6, security, Side.SELL, 350, 580, broker1, shareholder),
+                new Order(7, security, Side.SELL, 100, 581, broker2, shareholder)
+        );
+        orders.forEach(order -> security.getOrderBook().enqueue(order));
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createUpdateOrderRq(1, "ABC", 2, LocalDateTime.now(), Side.BUY, 500, 590, broker3.getBrokerId(), shareholder.getShareholderId(), 0));
+
+        assertThat(broker1.getCredit()).isEqualTo(100_000 + 350*580);
+        assertThat(broker2.getCredit()).isEqualTo(100_000 + 100*581);
+        assertThat(broker3.getCredit()).isEqualTo(100_000 + 430*550 - 350*580 - 100*581 - 50*590);
+    }
+
+    @Test
+    void update_order_changing_price_with_trades_for_buyer_with_insufficient_quantity_rolls_back() {
+        Broker broker1 = Broker.builder().brokerId(10).credit(100_000).build();
+        Broker broker2 = Broker.builder().brokerId(20).credit(100_000).build();
+        Broker broker3 = Broker.builder().brokerId(30).credit(54_000).build();
+        List.of(broker1, broker2, broker3).forEach(b -> brokerRepository.addBroker(b));
+        List<Order> orders = Arrays.asList(
+                new Order(1, security, Side.BUY, 304, 570, broker3, shareholder),
+                new Order(2, security, Side.BUY, 430, 550, broker3, shareholder),
+                new Order(3, security, Side.BUY, 445, 545, broker3, shareholder),
+                new Order(6, security, Side.SELL, 350, 580, broker1, shareholder),
+                new Order(7, security, Side.SELL, 100, 581, broker2, shareholder)
+        );
+        orders.forEach(order -> security.getOrderBook().enqueue(order));
+        Order originalOrder = orders.get(1).snapshot();
+        originalOrder.markAsQueued();
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createUpdateOrderRq(1, "ABC", 2, LocalDateTime.now(), Side.BUY, 500, 590, broker3.getBrokerId(), shareholder.getShareholderId(), 0));
+
+        assertThat(broker1.getCredit()).isEqualTo(100_000);
+        assertThat(broker2.getCredit()).isEqualTo(100_000);
+        assertThat(broker3.getCredit()).isEqualTo(54_000);
+        assertThat(originalOrder).isEqualTo(security.getOrderBook().findByOrderId(Side.BUY, 2));
+    }
+
+    @Test
+    void update_order_without_trade_decreasing_quantity_changes_buyers_credit() {
+        Broker broker1 = Broker.builder().brokerId(10).credit(100_000).build();
+        Broker broker2 = Broker.builder().brokerId(20).credit(100_000).build();
+        Broker broker3 = Broker.builder().brokerId(30).credit(100_000).build();
+        List.of(broker1, broker2, broker3).forEach(b -> brokerRepository.addBroker(b));
+        List<Order> orders = Arrays.asList(
+                new Order(1, security, Side.BUY, 304, 570, broker3, shareholder),
+                new Order(2, security, Side.BUY, 430, 550, broker3, shareholder),
+                new Order(3, security, Side.BUY, 445, 545, broker3, shareholder),
+                new Order(6, security, Side.SELL, 350, 580, broker1, shareholder),
+                new Order(7, security, Side.SELL, 100, 581, broker2, shareholder)
+        );
+        orders.forEach(order -> security.getOrderBook().enqueue(order));
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createUpdateOrderRq(1, "ABC", 2, LocalDateTime.now(), Side.BUY, 400, 550, broker3.getBrokerId(), shareholder.getShareholderId(), 0));
+
+        assertThat(broker1.getCredit()).isEqualTo(100_000);
+        assertThat(broker2.getCredit()).isEqualTo(100_000);
+        assertThat(broker3.getCredit()).isEqualTo(100_000 + 30*550);
+    }
+
+    @Test
+    void new_sell_order_without_enough_positions_is_rejected() {
+        List<Order> orders = Arrays.asList(
+                new Order(1, security, Side.BUY, 304, 570, broker3, shareholder),
+                new Order(2, security, Side.BUY, 430, 550, broker3, shareholder),
+                new Order(3, security, Side.BUY, 445, 545, broker3, shareholder),
+                new Order(6, security, Side.SELL, 350, 580, broker1, shareholder),
+                new Order(7, security, Side.SELL, 100, 581, broker2, shareholder)
+        );
+        orders.forEach(order -> security.getOrderBook().enqueue(order));
+        shareholder.decPosition(security, 99_500);
+        broker3.increaseCreditBy(100_000_000);
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createNewOrderRq(1, "ABC", 200, LocalDateTime.now(), Side.SELL, 400, 590, broker1.getBrokerId(), shareholder.getShareholderId(), 0,0));
+
+        verify(eventPublisher).publish(new OrderRejectedEvent(1, 200, List.of(Message.SELLER_HAS_NOT_ENOUGH_POSITIONS)));
+    }
+
+    @Test
+    void update_sell_order_without_enough_positions_is_rejected() {
+        List<Order> orders = Arrays.asList(
+                new Order(1, security, Side.BUY, 304, 570, broker3, shareholder),
+                new Order(2, security, Side.BUY, 430, 550, broker3, shareholder),
+                new Order(3, security, Side.BUY, 445, 545, broker3, shareholder),
+                new Order(6, security, Side.SELL, 350, 580, broker1, shareholder),
+                new Order(7, security, Side.SELL, 100, 581, broker2, shareholder)
+        );
+        orders.forEach(order -> security.getOrderBook().enqueue(order));
+        shareholder.decPosition(security, 99_500);
+        broker3.increaseCreditBy(100_000_000);
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createUpdateOrderRq(1, "ABC", 6, LocalDateTime.now(), Side.SELL, 450, 580, broker1.getBrokerId(), shareholder.getShareholderId(), 0));
+
+        verify(eventPublisher).publish(new OrderRejectedEvent(1, 6, List.of(Message.SELLER_HAS_NOT_ENOUGH_POSITIONS)));
+    }
+
+    @Test
+    void update_sell_order_with_enough_positions_is_executed() {
+        Shareholder shareholder1 = Shareholder.builder().build();
+        shareholder1.incPosition(security, 100_000);
+        shareholderRepository.addShareholder(shareholder1);
+        List<Order> orders = Arrays.asList(
+                new Order(1, security, Side.BUY, 304, 570, broker3, shareholder1),
+                new Order(2, security, Side.BUY, 430, 550, broker3, shareholder1),
+                new Order(3, security, Side.BUY, 445, 545, broker3, shareholder1),
+                new Order(6, security, Side.SELL, 350, 580, broker1, shareholder),
+                new Order(7, security, Side.SELL, 100, 581, broker2, shareholder)
+        );
+        orders.forEach(order -> security.getOrderBook().enqueue(order));
+        shareholder.decPosition(security, 99_500);
+        broker3.increaseCreditBy(100_000_000);
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createUpdateOrderRq(1, "ABC", 6, LocalDateTime.now(), Side.SELL, 250, 570, broker1.getBrokerId(), shareholder.getShareholderId(), 0));
+
+        verify(eventPublisher).publish(any(OrderExecutedEvent.class));
+        assertThat(shareholder1.hasEnoughPositionsOn(security, 100_000 + 250)).isTrue();
+        assertThat(shareholder.hasEnoughPositionsOn(security, 99_500 - 251)).isFalse();
+    }
+
+    @Test
+    void new_buy_order_does_not_check_for_position() {
+        Shareholder shareholder1 = Shareholder.builder().build();
+        shareholder1.incPosition(security, 100_000);
+        shareholderRepository.addShareholder(shareholder1);
+        List<Order> orders = Arrays.asList(
+                new Order(1, security, Side.BUY, 304, 570, broker3, shareholder1),
+                new Order(2, security, Side.BUY, 430, 550, broker3, shareholder1),
+                new Order(3, security, Side.BUY, 445, 545, broker3, shareholder1),
+                new Order(6, security, Side.SELL, 350, 580, broker1, shareholder),
+                new Order(7, security, Side.SELL, 100, 581, broker2, shareholder)
+        );
+        orders.forEach(order -> security.getOrderBook().enqueue(order));
+        shareholder.decPosition(security, 99_500);
+        broker3.increaseCreditBy(100_000_000);
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createNewOrderRq(1, "ABC", 200, LocalDateTime.now(), Side.BUY, 500, 570, broker3.getBrokerId(), shareholder.getShareholderId(), 0,0));
+
+        verify(eventPublisher).publish(any(OrderAcceptedEvent.class));
+        assertThat(shareholder1.hasEnoughPositionsOn(security, 100_000)).isTrue();
+        assertThat(shareholder.hasEnoughPositionsOn(security, 500)).isTrue();
+    }
+
+    @Test
+    void update_buy_order_does_not_check_for_position() {
+        Shareholder shareholder1 = Shareholder.builder().build();
+        shareholder1.incPosition(security, 100_000);
+        shareholderRepository.addShareholder(shareholder1);
+        List<Order> orders = Arrays.asList(
+                new Order(1, security, Side.BUY, 304, 570, broker3, shareholder1),
+                new Order(2, security, Side.BUY, 430, 550, broker3, shareholder1),
+                new Order(3, security, Side.BUY, 445, 545, broker3, shareholder1),
+                new Order(6, security, Side.SELL, 350, 580, broker1, shareholder),
+                new Order(7, security, Side.SELL, 100, 581, broker2, shareholder)
+        );
+        orders.forEach(order -> security.getOrderBook().enqueue(order));
+        shareholder.decPosition(security, 99_500);
+        broker3.increaseCreditBy(100_000_000);
+
+        orderHandler.handleEnterOrder(EnterOrderRq.createNewOrderRq(1, "ABC", 3, LocalDateTime.now(), Side.BUY, 500, 545, broker3.getBrokerId(), shareholder1.getShareholderId(), 0,0));
+
+        verify(eventPublisher).publish(any(OrderAcceptedEvent.class));
+        assertThat(shareholder1.hasEnoughPositionsOn(security, 100_000)).isTrue();
+        assertThat(shareholder.hasEnoughPositionsOn(security, 500)).isTrue();
+    }
+
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/domain/SecurityTest.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/domain/SecurityTest.java
new file mode 100644
index 0000000..447fd61
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/domain/SecurityTest.java
@@ -0,0 +1,232 @@
+package ir.ramtung.tinyme.domain;
+
+import ir.ramtung.tinyme.config.MockedJMSTestConfig;
+import ir.ramtung.tinyme.domain.entity.*;
+import ir.ramtung.tinyme.domain.service.MatchResult;
+import ir.ramtung.tinyme.domain.service.Matcher;
+import ir.ramtung.tinyme.domain.service.MatchingOutcome;
+import ir.ramtung.tinyme.messaging.exception.InvalidRequestException;
+import ir.ramtung.tinyme.messaging.request.DeleteOrderRq;
+import ir.ramtung.tinyme.messaging.request.EnterOrderRq;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.boot.test.context.SpringBootTest;
+import org.springframework.context.annotation.Import;
+
+import java.time.LocalDateTime;
+import java.util.Arrays;
+import java.util.List;
+
+import static ir.ramtung.tinyme.domain.entity.Side.BUY;
+import static ir.ramtung.tinyme.domain.entity.Side.SELL;
+import static org.assertj.core.api.Assertions.*;
+
+@SpringBootTest
+@Import(MockedJMSTestConfig.class)
+class SecurityTest {
+    private Security security;
+    private Broker broker;
+    private Shareholder shareholder;
+    private List<Order> orders;
+    @Autowired
+    Matcher matcher;
+
+    @BeforeEach
+    void setupOrderBook() {
+        security = Security.builder().build();
+        broker = Broker.builder().brokerId(0).credit(1_000_000L).build();
+        shareholder = Shareholder.builder().shareholderId(0).build();
+        shareholder.incPosition(security, 100_000);
+        orders = Arrays.asList(
+                new Order(1, security, BUY, 304, 15700, broker, shareholder),
+                new Order(2, security, BUY, 43, 15500, broker, shareholder),
+                new Order(3, security, BUY, 445, 15450, broker, shareholder),
+                new Order(4, security, BUY, 526, 15450, broker, shareholder),
+                new Order(5, security, BUY, 1000, 15400, broker, shareholder),
+                new Order(6, security, Side.SELL, 350, 15800, broker, shareholder),
+                new Order(7, security, Side.SELL, 285, 15810, broker, shareholder),
+                new Order(8, security, Side.SELL, 800, 15810, broker, shareholder),
+                new Order(9, security, Side.SELL, 340, 15820, broker, shareholder),
+                new Order(10, security, Side.SELL, 65, 15820, broker, shareholder)
+        );
+        orders.forEach(order -> security.getOrderBook().enqueue(order));
+    }
+
+    @Test
+    void reducing_quantity_does_not_change_priority() {
+        EnterOrderRq updateOrderRq = EnterOrderRq.createUpdateOrderRq(1, security.getIsin(), 3, LocalDateTime.now(), BUY, 440, 15450, 0, 0, 0);
+        assertThatNoException().isThrownBy(() -> security.updateOrder(updateOrderRq, matcher));
+        assertThat(security.getOrderBook().getBuyQueue().get(2).getQuantity()).isEqualTo(440);
+        assertThat(security.getOrderBook().getBuyQueue().get(2).getOrderId()).isEqualTo(3);
+    }
+
+    @Test
+    void increasing_quantity_changes_priority() {
+        EnterOrderRq updateOrderRq = EnterOrderRq.createUpdateOrderRq(1, security.getIsin(), 3, LocalDateTime.now(), BUY, 450, 15450, 0, 0, 0);
+        assertThatNoException().isThrownBy(() -> security.updateOrder(updateOrderRq, matcher));
+        assertThat(security.getOrderBook().getBuyQueue().get(3).getQuantity()).isEqualTo(450);
+        assertThat(security.getOrderBook().getBuyQueue().get(3).getOrderId()).isEqualTo(3);
+    }
+
+    @Test
+    void changing_price_changes_priority() {
+        EnterOrderRq updateOrderRq = EnterOrderRq.createUpdateOrderRq(1, security.getIsin(), 1, LocalDateTime.now(), BUY, 300, 15450, 0, 0, 0);
+        assertThatNoException().isThrownBy(() -> security.updateOrder(updateOrderRq, matcher));
+        assertThat(security.getOrderBook().getBuyQueue().get(3).getQuantity()).isEqualTo(300);
+        assertThat(security.getOrderBook().getBuyQueue().get(3).getPrice()).isEqualTo(15450);
+        assertThat(security.getOrderBook().getBuyQueue().get(3).getOrderId()).isEqualTo(1);
+        assertThat(security.getOrderBook().getBuyQueue().get(0).getOrderId()).isEqualTo(2);
+    }
+
+    @Test
+    void changing_price_causes_trades_to_happen() {
+        EnterOrderRq updateOrderRq = EnterOrderRq.createUpdateOrderRq(1, security.getIsin(), 6, LocalDateTime.now(), Side.SELL, 350, 15700, 0, 0, 0);
+        assertThatNoException().isThrownBy(() ->
+                assertThat(security.updateOrder(updateOrderRq, matcher).trades()).isNotEmpty()
+        );
+    }
+
+    @Test
+    void updating_non_existing_order_fails() {
+        EnterOrderRq updateOrderRq = EnterOrderRq.createUpdateOrderRq(1, security.getIsin(), 6, LocalDateTime.now(), BUY, 350, 15700, 0, 0, 0);
+        assertThatExceptionOfType(InvalidRequestException.class).isThrownBy(() -> security.updateOrder(updateOrderRq, matcher));
+    }
+
+    @Test
+    void delete_order_works() {
+        DeleteOrderRq deleteOrderRq = new DeleteOrderRq(1, security.getIsin(), Side.SELL, 6);
+        assertThatNoException().isThrownBy(() -> security.deleteOrder(deleteOrderRq));
+        assertThat(security.getOrderBook().getBuyQueue()).isEqualTo(orders.subList(0, 5));
+        assertThat(security.getOrderBook().getSellQueue()).isEqualTo(orders.subList(6, 10));
+    }
+
+    @Test
+    void deleting_non_existing_order_fails() {
+        DeleteOrderRq deleteOrderRq = new DeleteOrderRq(1, security.getIsin(), Side.SELL, 1);
+        assertThatExceptionOfType(InvalidRequestException.class).isThrownBy(() -> security.deleteOrder(deleteOrderRq));
+    }
+
+    @Test
+    void increasing_iceberg_peak_size_changes_priority() {
+        security = Security.builder().build();
+        broker = Broker.builder().credit(1_000_000L).build();
+        orders = Arrays.asList(
+                new Order(1, security, BUY, 304, 15700, broker, shareholder),
+                new Order(2, security, BUY, 43, 15500, broker, shareholder),
+                new IcebergOrder(3, security, BUY, 445, 15450, broker, shareholder, 100),
+                new Order(4, security, BUY, 526, 15450, broker, shareholder),
+                new Order(5, security, BUY, 1000, 15400, broker, shareholder)
+        );
+        orders.forEach(order -> security.getOrderBook().enqueue(order));
+        EnterOrderRq updateOrderRq = EnterOrderRq.createUpdateOrderRq(1, security.getIsin(), 3, LocalDateTime.now(), BUY, 445, 15450, 0, 0, 150);
+        assertThatNoException().isThrownBy(() -> security.updateOrder(updateOrderRq, matcher));
+        assertThat(security.getOrderBook().getBuyQueue().get(3).getQuantity()).isEqualTo(150);
+        assertThat(security.getOrderBook().getBuyQueue().get(3).getOrderId()).isEqualTo(3);
+    }
+
+    @Test
+    void decreasing_iceberg_quantity_to_amount_larger_than_peak_size_does_not_changes_priority() {
+        security = Security.builder().build();
+        broker = Broker.builder().build();
+        orders = Arrays.asList(
+                new Order(1, security, BUY, 304, 15700, broker, shareholder),
+                new Order(2, security, BUY, 43, 15500, broker, shareholder),
+                new IcebergOrder(3, security, BUY, 445, 15450, broker, shareholder, 100),
+                new Order(4, security, BUY, 526, 15450, broker, shareholder),
+                new Order(5, security, BUY, 1000, 15400, broker, shareholder)
+        );
+        orders.forEach(order -> security.getOrderBook().enqueue(order));
+        EnterOrderRq updateOrderRq = EnterOrderRq.createUpdateOrderRq(1, security.getIsin(), 3, LocalDateTime.now(), BUY, 300, 15450, 0, 0, 100);
+        assertThatNoException().isThrownBy(() -> security.updateOrder(updateOrderRq, matcher));
+        assertThat(security.getOrderBook().getBuyQueue().get(2).getOrderId()).isEqualTo(3);
+    }
+
+    @Test
+    void update_iceberg_that_loses_priority_with_no_trade_works() {
+        security = Security.builder().isin("TEST").build();
+        broker = Broker.builder().brokerId(1).credit(100).build();
+
+        security.getOrderBook().enqueue(
+                new IcebergOrder(1, security, BUY, 100, 9, broker, shareholder, 10)
+        );
+
+        EnterOrderRq updateReq = EnterOrderRq.createUpdateOrderRq(2, security.getIsin(), 1, LocalDateTime.now(), BUY, 100, 10, 0, 0, 10);
+        assertThatNoException().isThrownBy(() -> security.updateOrder(updateReq, matcher));
+
+        assertThat(broker.getCredit()).isEqualTo(0);
+        assertThat(security.getOrderBook().getBuyQueue().get(0).getOrderId()).isEqualTo(1);
+    }
+
+    @Test
+    void update_iceberg_order_decrease_peak_size() {
+        security = Security.builder().isin("TEST").build();
+        security.getOrderBook().enqueue(
+                new IcebergOrder(1, security, BUY, 20, 10, broker, shareholder, 10)
+        );
+
+        EnterOrderRq updateReq = EnterOrderRq.createUpdateOrderRq(2, security.getIsin(), 1, LocalDateTime.now(), BUY, 20, 10, 0, 0, 5);
+        assertThatNoException().isThrownBy(() -> security.updateOrder(updateReq, matcher));
+
+        assertThat(security.getOrderBook().getBuyQueue().get(0).getQuantity()).isEqualTo(5);
+    }
+
+    @Test
+    void update_iceberg_order_price_leads_to_match_as_new_order() throws InvalidRequestException {
+        security = Security.builder().isin("TEST").build();
+        shareholder.incPosition(security, 1_000);
+        orders = List.of(
+                new Order(1, security, BUY, 15, 10, broker, shareholder),
+                new Order(2, security, BUY, 20, 10, broker, shareholder),
+                new Order(3, security, BUY, 40, 10, broker, shareholder),
+                new IcebergOrder(4, security, SELL, 30, 12, broker, shareholder, 10)
+        );
+        orders.forEach(order -> security.getOrderBook().enqueue(order));
+
+        EnterOrderRq updateReq = EnterOrderRq.createUpdateOrderRq(5, security.getIsin(), 4, LocalDateTime.now(), SELL, 30, 10, 0, 0, 10);
+
+        MatchResult result = security.updateOrder(updateReq, matcher);
+
+        assertThat(result.outcome()).isEqualTo(MatchingOutcome.OK);
+        assertThat(result.trades()).hasSize(2);
+        assertThat(result.remainder().getQuantity()).isZero();
+    }
+
+
+    @Test
+    void updating_order_will_not_cause_MEQ_failure() throws InvalidRequestException {
+        Security security = Security.builder().isin("NEW_SE").build();
+        Order queuedOrder = new Order(1,
+                security,
+                Side.BUY,
+                500,
+                200,
+                100,
+                broker,
+                shareholder,
+                LocalDateTime.now(),
+                200,
+                OrderStatus.QUEUED);
+        security.getOrderBook().enqueue(queuedOrder);
+
+        EnterOrderRq updateReq = EnterOrderRq.createUpdateOrderRq(
+                2,
+                "ABC",
+                1,
+                LocalDateTime.now(),
+                Side.BUY,
+                400,
+                100,
+                broker.getBrokerId(),
+                shareholder.getShareholderId(),
+                0
+        );
+
+        MatchResult result = security.updateOrder(updateReq, matcher);
+
+        assertThat(result.outcome()).isEqualTo(MatchingOutcome.OK);
+
+    }
+
+
+}
\ No newline at end of file
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/messaging/EventPublisherTest.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/messaging/EventPublisherTest.java
new file mode 100644
index 0000000..3ece10f
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/messaging/EventPublisherTest.java
@@ -0,0 +1,52 @@
+package ir.ramtung.tinyme.messaging;
+
+import ir.ramtung.tinyme.messaging.event.OrderExecutedEvent;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.beans.factory.annotation.Value;
+import org.springframework.boot.test.context.SpringBootTest;
+import org.springframework.jms.annotation.EnableJms;
+import org.springframework.jms.core.JmsTemplate;
+import org.springframework.test.annotation.DirtiesContext;
+
+import java.util.List;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+//@Disabled
+@SpringBootTest
+@EnableJms
+@DirtiesContext
+public class EventPublisherTest {
+    @Autowired
+    JmsTemplate jmsTemplate;
+    @Autowired
+    EventPublisher eventPublisher;
+    @Value("${responseQueue}")
+    private String responseQueue;
+
+    @BeforeEach
+    void emptyResponseQueue() {
+        long receiveTimeout = jmsTemplate.getReceiveTimeout();
+        jmsTemplate.setReceiveTimeout(1000);
+        //noinspection StatementWithEmptyBody
+        while (jmsTemplate.receive(responseQueue) != null) ;
+        jmsTemplate.setReceiveTimeout(receiveTimeout);
+    }
+
+    @Disabled
+    @Test
+    void response_channel_integration_works() {
+        OrderExecutedEvent orderExecutedEvent = new OrderExecutedEvent(1, 0, List.of());
+        eventPublisher.publish(orderExecutedEvent);
+
+        long receiveTimeout = jmsTemplate.getReceiveTimeout();
+        jmsTemplate.setReceiveTimeout(1000);
+        OrderExecutedEvent responseReceived = (OrderExecutedEvent) jmsTemplate.receiveAndConvert(responseQueue);
+        assertEquals(orderExecutedEvent, responseReceived);
+
+        jmsTemplate.setReceiveTimeout(receiveTimeout);
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/messaging/RequestDispatcherTest.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/messaging/RequestDispatcherTest.java
new file mode 100644
index 0000000..860f56b
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/messaging/RequestDispatcherTest.java
@@ -0,0 +1,48 @@
+package ir.ramtung.tinyme.messaging;
+
+import ir.ramtung.tinyme.domain.entity.Side;
+import ir.ramtung.tinyme.messaging.request.EnterOrderRq;
+import ir.ramtung.tinyme.domain.service.OrderHandler;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.beans.factory.annotation.Value;
+import org.springframework.boot.test.context.SpringBootTest;
+import org.springframework.boot.test.mock.mockito.MockBean;
+import org.springframework.jms.annotation.EnableJms;
+import org.springframework.jms.core.JmsTemplate;
+
+import java.time.LocalDateTime;
+
+import static org.mockito.Mockito.timeout;
+import static org.mockito.Mockito.verify;
+
+//@Disabled
+@SpringBootTest
+@EnableJms
+public class RequestDispatcherTest {
+    @Autowired
+    private JmsTemplate jmsTemplate;
+    @MockBean
+    private OrderHandler mockOrderHandler;
+    @Value("${requestQueue}")
+    private String requestQueue;
+
+    @BeforeEach
+    void emptyRequestQueue() {
+        long receiveTimeout = jmsTemplate.getReceiveTimeout();
+        jmsTemplate.setReceiveTimeout(1000);
+        //noinspection StatementWithEmptyBody
+        while (jmsTemplate.receive(requestQueue) != null) ;
+        jmsTemplate.setReceiveTimeout(receiveTimeout);
+    }
+
+    @Disabled
+    @Test
+    void request_channel_integration_works() {
+        EnterOrderRq rq = EnterOrderRq.createNewOrderRq(1, "ABC", 200, LocalDateTime.now(), Side.SELL, 300, 15450, 0, 0, 0,0);
+        jmsTemplate.convertAndSend(requestQueue, rq);
+        verify(mockOrderHandler, timeout(1000)).handleEnterOrder(rq);
+    }
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/utils/FixtureDefaults.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/utils/FixtureDefaults.java
new file mode 100644
index 0000000..2194db8
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/utils/FixtureDefaults.java
@@ -0,0 +1,45 @@
+package ir.ramtung.tinyme.utils;
+
+
+import ir.ramtung.tinyme.domain.entity.Broker;
+import ir.ramtung.tinyme.domain.entity.Security;
+import ir.ramtung.tinyme.domain.entity.Shareholder;
+import ir.ramtung.tinyme.repository.BrokerRepository;
+import ir.ramtung.tinyme.repository.SecurityRepository;
+import ir.ramtung.tinyme.repository.ShareholderRepository;
+import lombok.AllArgsConstructor;
+import org.springframework.stereotype.Component;
+
+@Component
+@AllArgsConstructor
+public class FixtureDefaults {
+    private final SecurityRepository securityRepository;
+    private final BrokerRepository brokerRepository;
+    private final ShareholderRepository shareholderRepository;
+
+    public void init() {
+        Security security = Security.builder().isin(TestDefaults.ISIN).build();
+        securityRepository.addSecurity(security);
+
+        brokerRepository.addBroker(
+                Broker.builder()
+                        .brokerId(TestDefaults.BROKER_ID)
+                        .credit(1_000_000)
+                        .build());
+
+        Shareholder shareholder = Shareholder.builder().shareholderId(TestDefaults.SHAREHOLDER_ID).build();
+        shareholder.incPosition(security, 1000);
+        shareholderRepository.addShareholder(shareholder);
+    }
+
+    public void flush(){
+        shareholderRepository.clear();
+        brokerRepository.clear();
+        securityRepository.clear();
+    }
+
+    public Security getSecurity(){
+        return securityRepository.findSecurityByIsin(TestDefaults.ISIN);
+    }
+
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/utils/TestDefaults.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/utils/TestDefaults.java
new file mode 100644
index 0000000..7cd47d0
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/utils/TestDefaults.java
@@ -0,0 +1,12 @@
+package ir.ramtung.tinyme.utils;
+
+public interface TestDefaults {
+    long BROKER_ID = 112;
+    long SHAREHOLDER_ID = 1234;
+    String ISIN = "NEW_SE";
+    int PRICE = 100;
+    int QUANTITY = 100;
+    int PEAK_SIZE = 10;
+
+
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/utils/TestOrderBuilder.java b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/utils/TestOrderBuilder.java
new file mode 100644
index 0000000..3ae85dd
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/java/ir/ramtung/tinyme/utils/TestOrderBuilder.java
@@ -0,0 +1,163 @@
+package ir.ramtung.tinyme.utils;
+
+
+import ir.ramtung.tinyme.domain.entity.*;
+import ir.ramtung.tinyme.repository.BrokerRepository;
+import ir.ramtung.tinyme.repository.SecurityRepository;
+import ir.ramtung.tinyme.repository.ShareholderRepository;
+import org.springframework.stereotype.Component;
+
+import java.time.LocalDateTime;
+
+import static ir.ramtung.tinyme.domain.entity.Side.BUY;
+import static ir.ramtung.tinyme.utils.TestDefaults.*;
+
+@Component
+public class TestOrderBuilder {
+    private static int ORDER_ID = 1;
+
+    private final BrokerRepository brokerRepository;
+    private final ShareholderRepository shareholderRepository;
+    private final SecurityRepository securityRepository;
+
+    private Order.OrderBuilder orderBuilder;
+
+    public TestOrderBuilder(SecurityRepository securityRepository, BrokerRepository brokerRepository, ShareholderRepository shareholderRepository) {
+        this.securityRepository = securityRepository;
+        this.brokerRepository = brokerRepository;
+        this.shareholderRepository = shareholderRepository;
+    }
+
+    public TestOrderBuilder createOrder() {
+        Broker broker = brokerRepository.findBrokerById(BROKER_ID);
+        if (broker == null)
+            throw new IllegalStateException("Default Broker Not Defined");
+
+        Shareholder shareholder = shareholderRepository.findShareholderById(SHAREHOLDER_ID);
+        if (shareholder == null)
+            throw new IllegalStateException("Default Shareholder Not Defined");
+
+        Security security = securityRepository.findSecurityByIsin(ISIN);
+        if (security == null)
+            throw new IllegalStateException("Default Security Not Defined");
+
+        orderBuilder = Order.builder()
+                .orderId(ORDER_ID++)
+                .security(security)
+                .broker(broker)
+                .shareholder(shareholder)
+                .side(BUY)
+                .initialQuantity(QUANTITY)
+                .quantity(QUANTITY)
+                .price(PRICE)
+                .status(OrderStatus.NEW)
+                .entryTime(LocalDateTime.now())
+                .minimumExecutionQuantity(0);
+        return this;
+    }
+
+    public TestOrderBuilder createOrder(Security security, Shareholder shareholder, Broker broker) {
+        orderBuilder = Order.builder()
+                .orderId(ORDER_ID++)
+                .security(security)
+                .broker(broker)
+                .shareholder(shareholder)
+                .side(BUY)
+                .initialQuantity(QUANTITY)
+                .quantity(QUANTITY)
+                .price(PRICE)
+                .status(OrderStatus.NEW)
+                .entryTime(LocalDateTime.now())
+                .minimumExecutionQuantity(0);
+        return this;
+    }
+
+    public TestOrderBuilder createIcebergOrder() {
+        Security security = securityRepository.findSecurityByIsin(ISIN);
+        if (security == null)
+            throw new IllegalStateException("Default security Not Defined");
+
+        Broker broker = brokerRepository.findBrokerById(BROKER_ID);
+        if (broker == null)
+            throw new IllegalStateException("Default Broker Not Defined");
+
+        Shareholder shareholder = shareholderRepository.findShareholderById(SHAREHOLDER_ID);
+        if (shareholder == null)
+            throw new IllegalStateException("Default Shareholder Not Defined");
+
+        orderBuilder = IcebergOrder.builder()
+                .orderId(ORDER_ID++)
+                .security(security)
+                .broker(broker)
+                .shareholder(shareholder)
+                .side(BUY)
+                .initialQuantity(QUANTITY)
+                .quantity(QUANTITY)
+                .peakSize(PEAK_SIZE)
+                .displayedQuantity(PEAK_SIZE)
+                .price(PRICE)
+                .status(OrderStatus.NEW)
+                .entryTime(LocalDateTime.now())
+                .minimumExecutionQuantity(0);
+        return this;
+    }
+
+    public TestOrderBuilder createIcebergOrder(Security security, Shareholder shareholder, Broker broker) {
+        orderBuilder = IcebergOrder.builder()
+                .orderId(ORDER_ID++)
+                .security(security)
+                .broker(broker)
+                .shareholder(shareholder)
+                .side(BUY)
+                .initialQuantity(QUANTITY)
+                .quantity(QUANTITY)
+                .peakSize(PEAK_SIZE)
+                .displayedQuantity(PEAK_SIZE)
+                .price(PRICE)
+                .status(OrderStatus.NEW)
+                .entryTime(LocalDateTime.now())
+                .minimumExecutionQuantity(0);
+        return this;
+    }
+
+    public Order build() {
+        Order order = orderBuilder.build();
+        orderBuilder = null;
+        return order;
+    }
+
+    public TestOrderBuilder price(int price) {
+        orderBuilder.price(price);
+        return this;
+    }
+
+    public TestOrderBuilder quantity(int quantity) {
+        orderBuilder
+                .initialQuantity(quantity)
+                .quantity(quantity);
+        return this;
+    }
+
+    public TestOrderBuilder quantity(int quantity, int peakSize) {
+        if (!(orderBuilder instanceof IcebergOrder.IcebergOrderBuilder<?, ?>))
+            throw new IllegalStateException("Can not set peak size for order");
+
+        ((IcebergOrder.IcebergOrderBuilder<?, ?>) orderBuilder)
+                .peakSize(peakSize)
+                .displayedQuantity(Math.min(quantity, peakSize))
+                .initialQuantity(quantity)
+                .quantity(quantity);
+        return this;
+    }
+
+    public TestOrderBuilder side(Side side) {
+        orderBuilder.side(side);
+        return this;
+    }
+
+    public TestOrderBuilder minimumExecutionQuantity(int minimumExecutionQuantity) {
+        orderBuilder.minimumExecutionQuantity(minimumExecutionQuantity);
+        return this;
+    }
+
+}
diff --git a/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/resources/application.properties b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/resources/application.properties
new file mode 100644
index 0000000..57f460c
--- /dev/null
+++ b/TinyME-with-matching-controls_c02e28bc-b107-431f-b188-ef05b68a3b4e/src/test/resources/application.properties
@@ -0,0 +1,5 @@
+spring.artemis.mode=native
+spring.artemis.broker-url=tcp://127.0.0.1:61616
+requestQueue=RQ
+responseQueue=RS
+spring.profiles.active=test
\ No newline at end of file
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/Broker.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/Broker.java
index 4ca7d11..faa96fe 100644
--- a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/Broker.java
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/Broker.java
@@ -40,7 +40,7 @@ public class Broker {
 		credit -= amount;
 	}
 
-	private boolean hasEnoughCredit(long amount) {
+	public boolean hasEnoughCredit(long amount) {
 		return credit >= amount;
 	}
 }
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/IcebergOrder.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/IcebergOrder.java
index 4ad48a3..eb58a03 100644
--- a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/IcebergOrder.java
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/IcebergOrder.java
@@ -3,8 +3,8 @@ package ir.ramtung.tinyme.domain.entity;
 import ir.ramtung.tinyme.domain.exception.InvalidIcebergPeakSizeException;
 import ir.ramtung.tinyme.messaging.request.EnterOrderRq;
 import java.time.LocalDateTime;
+import java.util.ArrayList;
 import java.util.List;
-
 import lombok.EqualsAndHashCode;
 import lombok.Getter;
 import lombok.ToString;
@@ -224,7 +224,7 @@ public class IcebergOrder extends Order {
 			price,
 			broker,
 			shareholder,
-			entryTimes,
+			new ArrayList<>(entryTimes),
 			peakSize,
 			OrderStatus.SNAPSHOT
 		);
@@ -252,14 +252,8 @@ public class IcebergOrder extends Order {
 		if (status != OrderStatus.QUEUED) {
 			return super.getQuantity();
 		}
-		
-		return displayedQuantity;
-	}
 
-	@Override
-	public void queue() {
-		super.queue();
-		this.replenish();
+		return displayedQuantity;
 	}
 
 	@Override
@@ -274,18 +268,13 @@ public class IcebergOrder extends Order {
 
 		quantity -= amount;
 		displayedQuantity -= amount;
-		checkEmptyDisplayQuantity();
+		if (quantity == 0) {
+			this.status = OrderStatus.DONE;
+		}
 	}
 
-	private void checkEmptyDisplayQuantity() {
-		if (displayedQuantity == 0) {
-			status = OrderStatus.DONE;
-			security.deleteOrder(side, orderId);
-			if (quantity != 0) {
-				this.entryTimes.add(LocalDateTime.now());
-				security.getOrderBook().enqueue(this);
-			}
-		}
+	public boolean isDisplayZero() {
+		return displayedQuantity == 0;
 	}
 
 	@Override
@@ -327,4 +316,8 @@ public class IcebergOrder extends Order {
 		IcebergOrder tempIcebergOrder = (IcebergOrder) tempOrder;
 		return this.peakSize < tempIcebergOrder.peakSize;
 	}
+
+	public void addUpdateTime(LocalDateTime updateTime) {
+		entryTimes.add(updateTime);
+	}
 }
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/MatchResult.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/MatchResult.java
index 1d168ff..c3cfea3 100644
--- a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/MatchResult.java
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/MatchResult.java
@@ -1,5 +1,6 @@
 package ir.ramtung.tinyme.domain.entity;
 
+import ir.ramtung.tinyme.domain.service.controls.ControlResult;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Objects;
@@ -26,6 +27,19 @@ public final class MatchResult {
 		return new MatchResult(MatchingOutcome.NOT_ENOUGH_EXECUTION, null, new LinkedList<>());
 	}
 
+	public static MatchResult createFromControlResult(ControlResult controlResult) {
+		switch (controlResult) {
+			case NOT_ENOUGH_POSITION:
+				return notEnoughPositions();
+			case NOT_ENOUGH_CREDIT:
+				return notEnoughCredit();
+			case NOT_ENOUGH_EXECUTION:
+				return notEnoughExecution();
+			default:
+				throw new UnknownError("Unknown Control Result");
+		}
+	}
+
 	private MatchResult(MatchingOutcome outcome, Order remainder, LinkedList<Trade> trades) {
 		this.outcome = outcome;
 		this.remainder = remainder;
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/Order.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/Order.java
index 966afcc..4dbe88c 100644
--- a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/Order.java
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/Order.java
@@ -3,7 +3,6 @@ package ir.ramtung.tinyme.domain.entity;
 import ir.ramtung.tinyme.domain.exception.CantQueueOrderException;
 import ir.ramtung.tinyme.domain.exception.InvalidPeakSizeException;
 import ir.ramtung.tinyme.domain.exception.InvalidStopLimitPriceException;
-import ir.ramtung.tinyme.domain.exception.NotEnoughExecutionException;
 import ir.ramtung.tinyme.domain.exception.UpdateMinimumExecutionQuantityException;
 import ir.ramtung.tinyme.messaging.request.EnterOrderRq;
 import java.time.LocalDateTime;
@@ -222,7 +221,7 @@ public class Order {
 			price,
 			broker,
 			shareholder,
-			entryTimes,
+			new ArrayList<>(entryTimes),
 			OrderStatus.SNAPSHOT
 		);
 	}
@@ -262,15 +261,17 @@ public class Order {
 		quantity -= amount;
 		if (quantity == 0 && status == OrderStatus.QUEUED) {
 			status = OrderStatus.DONE;
-			security.deleteOrder(side, orderId);
 		}
 	}
 
 	public void rollback(Order firstVersion) {
 		this.quantity = firstVersion.quantity;
-		if (status == OrderStatus.DONE) {
-			security.getOrderBook().enqueue(this);
-		}
+		copyEntryTimes(firstVersion.entryTimes);
+	}
+
+	private void copyEntryTimes(List<LocalDateTime> entryTimes) {
+		this.entryTimes.clear();
+		entryTimes.forEach(time -> this.entryTimes.add(time));
 	}
 
 	public void makeQuantityZero() {
@@ -293,10 +294,6 @@ public class Order {
 		if (this.status == OrderStatus.QUEUED) {
 			throw new CantQueueOrderException();
 		}
-
-		if (side == Side.BUY && status != OrderStatus.LOADING) {
-			broker.decreaseCreditBy(this.getValue());
-		}
 		status = OrderStatus.QUEUED;
 	}
 
@@ -342,10 +339,24 @@ public class Order {
 		} 
 	}
 
-	public void checkExecutionQuantity(int quantitySome) {
-		if (!(this.status != OrderStatus.NEW) && (quantitySome < this.minimumExecutionQuantity)) {
-			throw new NotEnoughExecutionException();
-		}
+	public boolean isNew() {
+		return this.status == OrderStatus.NEW;
+	}
+
+	public boolean isQueued() {
+		return this.status == OrderStatus.QUEUED;
+	}
+
+	public boolean isDone() {
+		return this.status == OrderStatus.DONE;
+	}
+
+	public boolean isDeleted() {
+		return this.status == OrderStatus.DELETED;
+	}
+
+	public boolean isMinimumExecuteQuantitySatisfied(int executedQuantity) {
+		return this.minimumExecutionQuantity <= executedQuantity;
 	}
 
 	public void addYourselfToQueue() {
@@ -355,12 +366,18 @@ public class Order {
 	}
 
 	public void delete() {
-		if (side == Side.BUY) {
-			broker.increaseCreditBy(getValue());
-		}
+		this.status = OrderStatus.DELETED;
 	}
 
 	public boolean willPriorityLostInUpdate(Order tempOrder) {
 		return (this.quantity < tempOrder.quantity) || (this.price != tempOrder.price);
 	}
+
+	public boolean isBuy() {
+		return this.side == Side.BUY;
+	}
+
+	public boolean isSell() {
+		return this.side == Side.SELL;
+	}
 }
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/OrderBook.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/OrderBook.java
index 2101be1..487e75a 100644
--- a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/OrderBook.java
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/OrderBook.java
@@ -115,12 +115,15 @@ public class OrderBook {
 
 	public Order findOrderToMatchWith(Order newOrder) {
 		var queue = getQueue(newOrder.getSide().opposite());
+		if (queue.isEmpty()) {
+			return null;
+		}
 
 		if (newOrder.matches(queue.getFirst())) {
 			return queue.getFirst();
 		}
 
-		throw new NotFoundException();
+		return null;
 	}
 
 	public void putBack(Order order) {
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/OrderStatus.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/OrderStatus.java
index 292e676..4d8b592 100644
--- a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/OrderStatus.java
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/OrderStatus.java
@@ -7,4 +7,5 @@ public enum OrderStatus {
 	SNAPSHOT,
 	LOADING,
 	DONE,
+	DELETED,
 }
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/Security.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/Security.java
index 31589ee..636bb8a 100644
--- a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/Security.java
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/Security.java
@@ -1,20 +1,20 @@
 package ir.ramtung.tinyme.domain.entity;
 
-import ir.ramtung.tinyme.domain.entity.security_stats.AuctionStats;
-import ir.ramtung.tinyme.domain.entity.security_stats.ExecuteStats;
-import ir.ramtung.tinyme.domain.entity.security_stats.SecurityStats;
-import ir.ramtung.tinyme.domain.entity.security_stats.SituationalStats;
-import ir.ramtung.tinyme.domain.entity.security_stats.StateStats;
-import ir.ramtung.tinyme.domain.exception.NotEnoughCreditException;
-import ir.ramtung.tinyme.domain.exception.NotEnoughPositionException;
-import ir.ramtung.tinyme.domain.exception.UnknownSecurityStateException;
+import ir.ramtung.tinyme.domain.entity.stats.ExecuteStats;
+import ir.ramtung.tinyme.domain.entity.stats.SecurityStats;
 import ir.ramtung.tinyme.domain.service.Matcher;
+import ir.ramtung.tinyme.domain.service.controls.AuctionMatchingControl;
+import ir.ramtung.tinyme.domain.service.controls.ContinuousMatchingControl;
+import ir.ramtung.tinyme.domain.service.controls.CreditControl;
+import ir.ramtung.tinyme.domain.service.controls.PositionControl;
+import ir.ramtung.tinyme.domain.service.controls.QuantityControl;
+import ir.ramtung.tinyme.domain.service.security_state.AuctionBehave;
+import ir.ramtung.tinyme.domain.service.security_state.ContinuousBehave;
+import ir.ramtung.tinyme.domain.service.security_state.SecurityBehave;
 import ir.ramtung.tinyme.messaging.Message;
 import ir.ramtung.tinyme.messaging.request.EnterOrderRq;
-import java.util.ArrayList;
 import java.util.LinkedList;
 import java.util.List;
-
 import lombok.Builder;
 import lombok.Getter;
 
@@ -35,262 +35,84 @@ public class Security {
 
 	private int lastTradePrice;
 
-	private static Matcher matcher = new Matcher();
+	// TODO: find a better way to inject these dependencies
+	private static PositionControl positionControl = new PositionControl();
+	private static CreditControl creditControl = new CreditControl();
+	private static QuantityControl quantityControl = new QuantityControl();
+	private static Matcher matcher = new Matcher(
+		new ContinuousMatchingControl(positionControl, creditControl, quantityControl),
+		new AuctionMatchingControl(positionControl, creditControl, quantityControl)
+	);
+	private static ContinuousBehave continuousBehave = new ContinuousBehave(positionControl, creditControl, matcher);
+	private static AuctionBehave auctionBehave = new AuctionBehave(positionControl, creditControl, matcher);
+
+	@Builder.Default
+	private SecurityBehave currentBehave = continuousBehave;
 
 	@Builder.Default
 	private SecurityState state = SecurityState.CONTINUOUS;
 
 	public SecurityResponse addNewOrder(Order newOrder) {
-		try {
-			checkPositionForNewOrder(newOrder);
-			List<SecurityStats> stats = handleAdd(newOrder);
-			return new SecurityResponse(stats);
-		} catch (NotEnoughPositionException exp) {
-			return new SecurityResponse(SituationalStats.createNotEnoughPositionsStats(newOrder.getOrderId()));
-		} catch (NotEnoughCreditException exp) {
-			return new SecurityResponse(SituationalStats.createNotEnoughCreditStats(newOrder.getOrderId()));
-		}
-	}
-
-	private List<SecurityStats> handleAdd(Order newOrder) {
-		if (this.state == SecurityState.CONTINUOUS) {
-			return handleAddInContinuousState(newOrder);
-		} else if (this.state == SecurityState.AUCTION) {
-			return handleAddInAuctionState(newOrder);
-		} else {
-			throw new UnknownSecurityStateException();
-		}
-	}
-
-	private List<SecurityStats> handleAddInAuctionState(Order newOrder) {
-		orderBook.enqueue(newOrder);
-
-		List<SecurityStats> stats = new ArrayList<>();
-		stats.add(SituationalStats.createAddOrderStats(newOrder.getOrderId()));
-		stats.add(createAuctionStats());
-		return stats;
-	}
-
-	private List<SecurityStats> handleAddInContinuousState(Order newOrder) {
-		List<SecurityStats> stats = new ArrayList<>();
-		if (newOrder instanceof StopLimitOrder newStopLimitOrder) {
-			stats.addAll(addNewStopLimitOrder(newStopLimitOrder));
-		} else {
-			stats.addAll(addNewLimitOrderInContinuousState(newOrder));
-		}
-		stats.addAll(activateStopLimitOrders());
-		return stats;
-	}
-
-	private void updateLastTradePrice(List<Trade> trades) {
-		if (!trades.isEmpty()) {
-			lastTradePrice = trades.getLast().getPrice();
-		}
-	}
-
-	private List<SecurityStats> addNewStopLimitOrder(StopLimitOrder newOrder) {
-		orderBook.enqueue(newOrder);
-		return List.of(SituationalStats.createAddOrderStats(newOrder.getOrderId()));
+		List<SecurityStats> stats = currentBehave.addNewOrder(newOrder, orderBook, lastTradePrice);
+		updateLastTradePrice(stats);
+		activateStopLimitOrders(stats);
+		return new SecurityResponse(stats);
 	}
 
-	private List<SecurityStats> addNewLimitOrderInContinuousState(Order newOrder) {
-		List<SecurityStats> stats = new ArrayList<>();
-		stats.add(SituationalStats.createAddOrderStats(newOrder.getOrderId()));
-
-		MatchResult newOrderMatchResult = matcher.continuousExecuting(newOrder);
-		if (!newOrderMatchResult.isSuccessful()) {
-			stats.set(0, SituationalStats.createExecutionStatsFromUnsuccessfulMatchResult(newOrderMatchResult, newOrder.getOrderId()));
-		}
-		if(!newOrderMatchResult.trades().isEmpty()) {
-			stats.add(ExecuteStats.createContinuousExecuteStats(newOrderMatchResult.trades(), newOrder.getOrderId()));
-		}
-		updateLastTradePrice(newOrderMatchResult.trades());
-		return stats;
+	public SecurityResponse updateOrder(Order tempOrder) {
+		Order mainOrder = findByOrderId(tempOrder.getSide(), tempOrder.getOrderId());
+		List<SecurityStats> stats = currentBehave.updateOrder(tempOrder, mainOrder, orderBook, lastTradePrice);
+		updateLastTradePrice(stats);
+		activateStopLimitOrders(stats);
+		return new SecurityResponse(stats);
 	}
 
-	private void checkPositionForNewOrder(Order newOrder) {
-		if (newOrder.getSide() == Side.BUY) {
-			return;
-		}
-
-		Shareholder shareholder = newOrder.getShareholder();
-		int salesAmount = newOrder.getQuantity();
-		int queuedPositionAmount = orderBook.totalSellQuantityByShareholder(shareholder);
-		int totalNeededPosition = salesAmount + queuedPositionAmount;
-
-		if (!shareholder.hasEnoughPositionsOn(this, totalNeededPosition)) {
-			throw new NotEnoughPositionException();
-		}
+	private void activateStopLimitOrders(List<SecurityStats> stats) {
+		stats.addAll(currentBehave.activateStopLimitOrders(orderBook, lastTradePrice));
+		updateLastTradePrice(stats);
 	}
 
 	public SecurityResponse deleteOrder(Side side, long orderId) {
-		orderBook.removeByOrderId(side, orderId);
-
-		List<SecurityStats> stats = new ArrayList<>();
-		stats.add(SituationalStats.createDeleteOrderStats(orderId));
-		if (this.state == SecurityState.AUCTION) {
-			stats.add(createAuctionStats());
-		}
+		Order order = findByOrderId(side, orderId);
+		List<SecurityStats> stats = currentBehave.deleteOrder(order, orderBook, lastTradePrice);
 		return new SecurityResponse(stats);
 	}
 
 	public SecurityResponse changeMatchingState(SecurityState newState) {
-		StateStats stateStats = StateStats.createStateStats(this.state, newState);
-		SecurityState prevState = this.state;
-		this.state = newState;
-		if (prevState == SecurityState.CONTINUOUS) {
-			return new SecurityResponse(stateStats);
-		} else if (prevState == SecurityState.AUCTION) {
-			List<SecurityStats> stats = openAuction();
-			stats.add(stateStats);
-			stats.addAll(activateStopLimitOrders());
-			return new SecurityResponse(stats);
-		} else {
-			throw new UnknownSecurityStateException();
-		}
-	}
-
-	private List<SecurityStats> openAuction() {
-		List<SecurityStats> stats = new ArrayList<>();
-
-		List<Trade> trades = matcher.auctionExecuting(orderBook, lastTradePrice);
-		if (!trades.isEmpty()) {
-			stats.add(ExecuteStats.createAuctionExecuteStats(trades));
-		}
-
-		updateLastTradePrice(trades);
-
-		return stats;
-	}
-
-	public SecurityResponse updateOrder(Order tempOrder) {
-		try {
-			Order mainOrder = findByOrderId(tempOrder.getSide(), tempOrder.getOrderId());
-			checkPositionForUpdateOrder(mainOrder, tempOrder);
-			List<SecurityStats> stats = handleUpdate(tempOrder, mainOrder);
-			return new SecurityResponse(stats);
-		} catch (NotEnoughPositionException exp) {
-			return new SecurityResponse(SituationalStats.createNotEnoughPositionsStats(tempOrder.getOrderId()));
-		}
-	}
-
-	private List<SecurityStats> handleUpdate(Order tempOrder, Order mainOrder) {
-		boolean losesPriority = mainOrder.willPriorityLostInUpdate(tempOrder);
-		if (losesPriority) {
-			Order originalOrder = mainOrder.snapshot();
-			orderBook.removeByOrderId(originalOrder.getSide(), originalOrder.getOrderId());
-			mainOrder.updateFromTempOrder(tempOrder);
-			return reAddUpdatedOrder(mainOrder, originalOrder);
-		} else {
-			return updateByKeepingPriority(tempOrder, mainOrder);
-		}
-	}
-
-	private List<SecurityStats> updateByKeepingPriority(Order tempOrder, Order mainOrder) {
-		if (this.state == SecurityState.CONTINUOUS) {
-			return updateByKeepingPriorityInContinuousState(tempOrder, mainOrder);
-		} else if (this.state == SecurityState.AUCTION) {
-			return updateByKeepingPriorityInAuctionState(tempOrder, mainOrder);
-		} else {
-			throw new UnknownSecurityStateException();
-		}
-	}
-
-	private List<SecurityStats> updateByKeepingPriorityInContinuousState(Order tempOrder, Order mainOrder) {
-		mainOrder.updateFromTempOrder(tempOrder);
-		return List.of(SituationalStats.createUpdateOrderStats(mainOrder.getOrderId()));
-	}
-
-	private List<SecurityStats> updateByKeepingPriorityInAuctionState(Order tempOrder, Order mainOrder) {
-		mainOrder.updateFromTempOrder(tempOrder);
-		
-		List<SecurityStats> stats = new ArrayList<>();
-		stats.add(SituationalStats.createUpdateOrderStats(mainOrder.getOrderId()));
-		stats.add(createAuctionStats());
-		return stats;
-	}
-
-	private List<SecurityStats> reAddUpdatedOrder(Order updatedOrder, Order originalOrder) {
-		if (this.state == SecurityState.CONTINUOUS) {
-			return reAddUpdatedOrderInContinuousState(updatedOrder, originalOrder);
-		} else if (this.state == SecurityState.AUCTION) {
-			return reAddUpdatedOrderInAuctionState(updatedOrder, originalOrder);
-		} else {
-			throw new UnknownSecurityStateException();
-		}
-	}
-
-	private List<SecurityStats> reAddUpdatedOrderInContinuousState(Order updatedOrder, Order originalOrder) {
-		if (updatedOrder instanceof StopLimitOrder updatedSlo) {
-			StopLimitOrder originalSlo = (StopLimitOrder) originalOrder;
-			return reAddUpdatedSloInContinuousState(updatedSlo, originalSlo);
-		} else {
-			return reAddActiveOrderInContinuousState(updatedOrder, originalOrder);
-		}
+		List<SecurityStats> stats = currentBehave.changeMatchingState(orderBook, lastTradePrice, newState);
+		updateLastTradePrice(stats);
+		currentBehave = getBehaveForState(newState);
+		processChangeToAuctionState(stats);
+		setState(newState);
+		return new SecurityResponse(stats);
 	}
 
-	private List<SecurityStats> reAddUpdatedOrderInAuctionState(Order updatedOrder, Order originalOrder) {
-		try {
-			orderBook.enqueue(updatedOrder);
-			List<SecurityStats> stats = new LinkedList<>();
-			stats.add(SituationalStats.createUpdateOrderStats(originalOrder.getOrderId()));
-			stats.add(createAuctionStats());
-			return stats;
-		} catch (NotEnoughCreditException e) {
-			orderBook.enqueue(originalOrder);
-			return List.of(SituationalStats.createNotEnoughCreditStats(originalOrder.getOrderId()));
+	private void processChangeToAuctionState(List<SecurityStats> stats) {
+		if (this.state == SecurityState.AUCTION) {
+			activateStopLimitOrders(stats);
 		}
 	}
 
-	private List<SecurityStats> reAddActiveOrderInContinuousState(Order updatedOrder, Order originalOrder) {
-		List<SecurityStats> stats = new LinkedList<>();
-		stats.add(SituationalStats.createUpdateOrderStats(originalOrder.getOrderId()));
-		
-		MatchResult updatedOrderResult = matcher.continuousExecuting(updatedOrder);
-
-		if (!updatedOrderResult.isSuccessful()) {
-			orderBook.enqueue(originalOrder);
-			stats.set(0, SituationalStats.createExecutionStatsFromUnsuccessfulMatchResult(updatedOrderResult, originalOrder.getOrderId()));
-		} 
-		if (!updatedOrderResult.trades().isEmpty()) {
-			stats.add(ExecuteStats.createContinuousExecuteStats(updatedOrderResult.trades(), originalOrder.getOrderId()));
-		}
-
-		updateLastTradePrice(updatedOrderResult.trades());
-		stats.addAll(activateStopLimitOrders());
-		return stats;
+	private void setState(SecurityState newState) {
+		this.state = newState;
 	}
 
-	private List<SecurityStats> reAddUpdatedSloInContinuousState(StopLimitOrder updatedOrder,StopLimitOrder originalOrder) {
-		try {
-			List<SecurityStats> stats = new LinkedList<>();
-			stats.add(SituationalStats.createUpdateOrderStats(originalOrder.getOrderId()));
-			orderBook.enqueue(updatedOrder);
-			stats.addAll(activateStopLimitOrders());
-			return stats;
-		} catch (NotEnoughCreditException exp) {
-			orderBook.enqueue(originalOrder);
-			return List.of(SituationalStats.createNotEnoughCreditStats(originalOrder.getOrderId()));
-		}
+	private SecurityBehave getBehaveForState(SecurityState newState) {
+		return (newState == SecurityState.AUCTION) ? auctionBehave : continuousBehave;
 	}
 
-	private void checkPositionForUpdateOrder(Order mainOrder, Order tempOrder) {
-		if (mainOrder.getSide() == Side.BUY) return;
-
-		Shareholder shareholder = mainOrder.getShareholder();
-		int pervSalesAmount = mainOrder.getTotalQuantity();
-		int newSalesAmount = tempOrder.getTotalQuantity();
-		int queuedPositionAmount = orderBook.totalSellQuantityByShareholder(shareholder);
-		int totalNeededPosition = newSalesAmount + queuedPositionAmount - pervSalesAmount;
-
-		if (!shareholder.hasEnoughPositionsOn(this, totalNeededPosition)) {
-			throw new NotEnoughPositionException();
+	private void updateLastTradePrice(List<SecurityStats> stats) {
+		for (SecurityStats stat : stats.reversed()) {
+			if (stat instanceof ExecuteStats exeStat) {
+				lastTradePrice = exeStat.getTrades().getLast().getPrice();
+				return;
+			}
 		}
 	}
 
 	public List<String> checkEnterOrderRq(EnterOrderRq order) {
 		List<String> errors = new LinkedList<>();
-		
+
 		if (order.getQuantity() % lotSize != 0) {
 			errors.add(Message.QUANTITY_NOT_MULTIPLE_OF_LOT_SIZE);
 		}
@@ -299,51 +121,17 @@ public class Security {
 			errors.add(Message.PRICE_NOT_MULTIPLE_OF_TICK_SIZE);
 		}
 
-		if(this.state == SecurityState.AUCTION && order.getMinimumExecutionQuantity() != 0) {
+		if (this.state == SecurityState.AUCTION && order.getMinimumExecutionQuantity() != 0) {
 			errors.add(Message.MINIMUM_EXECUTION_IN_AUCTION_STATE);
 		}
 
-		if(this.state == SecurityState.AUCTION && order.getStopPrice() != 0) {
+		if (this.state == SecurityState.AUCTION && order.getStopPrice() != 0) {
 			errors.add(Message.STOP_PRICE_IN_AUCTION_STATE);
 		}
 
 		return errors;
 	}
 
-	private List<SecurityStats> activateStopLimitOrders() {
-		List<SecurityStats> stats = new LinkedList<>();
-		StopLimitOrder slo;
-
-		while ((slo = orderBook.getStopLimitOrder(lastTradePrice)) != null) {
-			stats.add(SituationalStats.createOrderActivatedStats(slo.getOrderId(), slo.getRequestId()));
-			Order activatedOrder = new Order(slo);
-			if (this.state == SecurityState.CONTINUOUS) {
-				stats.addAll(activateOrderInContinuousState(activatedOrder, slo.getRequestId()));
-			} else if (this.state == SecurityState.AUCTION) {
-				stats.addAll(activateOrderInAuctionState(activatedOrder));
-			} else {
-				throw new UnknownSecurityStateException();
-			}
-		}
-
-		return stats;
-	}
-
-	private List<SecurityStats> activateOrderInContinuousState(Order activatedOrder, long requestId) {
-		MatchResult result = matcher.continuousExecuting(activatedOrder);
-		updateLastTradePrice(result.trades());
-		if(!result.trades().isEmpty()) {
-			return List.of(ExecuteStats.createContinuousExecuteStatsForActivatedOrder(result.trades(), activatedOrder.getOrderId(), requestId));
-		} else {
-			return List.of();
-		}
-	}
-
-	private List<SecurityStats> activateOrderInAuctionState(Order activatedOrder) {
-		orderBook.enqueue(activatedOrder);
-		return List.of();
-	}
-
 	public Order findByOrderId(Side side, long orderId) {
 		return orderBook.findByOrderId(side, orderId);
 	}
@@ -356,9 +144,4 @@ public class Security {
 		Order order = orderBook.findByOrderId(side, orderId);
 		return (order instanceof StopLimitOrder);
 	}
-	private AuctionStats createAuctionStats() {
-		int openingPrice = matcher.calcOpeningAuctionPrice(orderBook, lastTradePrice);
-		int tradableQuantity = matcher.calcTradableQuantity(orderBook, openingPrice);
-		return AuctionStats.createAuctionStats(openingPrice, tradableQuantity);
-	}
 }
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/SecurityResponse.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/SecurityResponse.java
index b5664a2..ee41145 100644
--- a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/SecurityResponse.java
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/SecurityResponse.java
@@ -3,7 +3,7 @@ package ir.ramtung.tinyme.domain.entity;
 import java.util.ArrayList;
 import java.util.List;
 
-import ir.ramtung.tinyme.domain.entity.security_stats.SecurityStats;
+import ir.ramtung.tinyme.domain.entity.stats.SecurityStats;
 import lombok.Getter;
 
 @Getter
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/security_stats/AuctionStats.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/security_stats/AuctionStats.java
deleted file mode 100644
index c9a4869..0000000
--- a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/security_stats/AuctionStats.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package ir.ramtung.tinyme.domain.entity.security_stats;
-
-import lombok.Getter;
-
-@Getter
-public class AuctionStats extends SecurityStats {
-    int openingPrice;
-    int tradableQuantity;
-
-    private AuctionStats(int openingPrice, int tradableQuantity) {
-        this.openingPrice = openingPrice;
-        this.tradableQuantity = tradableQuantity;
-    }
-
-    public static AuctionStats createAuctionStats(int openingPrice, int tradableQuantity) {
-        return new AuctionStats(openingPrice, tradableQuantity);
-    }
-}
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/security_stats/ExecuteStats.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/security_stats/ExecuteStats.java
deleted file mode 100644
index 2c5f289..0000000
--- a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/security_stats/ExecuteStats.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package ir.ramtung.tinyme.domain.entity.security_stats;
-
-import java.util.List;
-
-import ir.ramtung.tinyme.domain.entity.SecurityState;
-import ir.ramtung.tinyme.domain.entity.Trade;
-import lombok.Getter;
-
-@Getter
-public class ExecuteStats extends SecurityStats {
-    private long orderId;
-    private long requestId;
-    private List<Trade> trades;
-    private SecurityState securityState;
-    private boolean isForActivatedOrder;
-
-    private ExecuteStats(long orderId, List<Trade> trades, SecurityState securityState) {
-        this.orderId = orderId;
-        this.trades = trades;
-        this.securityState = securityState;
-        this.isForActivatedOrder = false;
-    }
-
-    private ExecuteStats(long orderId, long requestId, boolean isForActivatedOrder, List<Trade> trades, SecurityState securityState) {
-        this(orderId, trades, securityState);
-        this.requestId = requestId;
-        this.isForActivatedOrder = isForActivatedOrder;
-    }
-
-    public static ExecuteStats createAuctionExecuteStats(List<Trade> trades) {
-        return new ExecuteStats(0, trades, SecurityState.AUCTION);
-    }
-
-    public static ExecuteStats createContinuousExecuteStats(List<Trade> trades, long orderId) {
-        return new ExecuteStats(orderId, trades, SecurityState.CONTINUOUS);
-    }
-
-    public static ExecuteStats createContinuousExecuteStatsForActivatedOrder(List<Trade> trades, long orderId, long requestId) {
-        return new ExecuteStats(orderId, requestId, true, trades, SecurityState.CONTINUOUS);
-    }
-
-    public long getOrderId() {
-        if (securityState == SecurityState.AUCTION) {
-            throw new IllegalStateException("Action execute stats can not have order id");
-        }
-        return this.orderId;
-    }
-
-    public long getRequestId(){
-        if (!isForActivatedOrder) {
-            throw new IllegalStateException("Only order activated execution stats has requestId");
-        }
-        return requestId;
-    }
-
-    public boolean isForActivatedOrder() {
-        return isForActivatedOrder;
-    }
-    
-    public boolean isAuction() {
-        return securityState == SecurityState.AUCTION;
-    }
-
-    public boolean isCountinues() {
-        return securityState == SecurityState.CONTINUOUS;
-    }
-}
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/security_stats/SecurityStats.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/security_stats/SecurityStats.java
deleted file mode 100644
index 93baf56..0000000
--- a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/security_stats/SecurityStats.java
+++ /dev/null
@@ -1,8 +0,0 @@
-package ir.ramtung.tinyme.domain.entity.security_stats;
-
-import lombok.Getter;
-
-@Getter
-public abstract class SecurityStats {
-	
-}
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/security_stats/SituationalStats.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/security_stats/SituationalStats.java
deleted file mode 100644
index 02aca6e..0000000
--- a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/security_stats/SituationalStats.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package ir.ramtung.tinyme.domain.entity.security_stats;
-
-import ir.ramtung.tinyme.domain.entity.MatchResult;
-import ir.ramtung.tinyme.domain.entity.MatchingOutcome;
-import lombok.Getter;
-
-@Getter
-public class SituationalStats extends SecurityStats {
-
-    private long orderId;
-    private long requestId;
-    private SituationalStatsType type;
-
-    private SituationalStats (long orderId, SituationalStatsType type) {
-        this.orderId = orderId;
-        this.type = type;
-    }
-
-    private SituationalStats (long orderId, long requestId, SituationalStatsType type) {
-        this(orderId, type);
-        this.requestId = requestId;
-    }
-
-	public static SecurityStats createAddOrderStats(long orderId) {
-		return new SituationalStats(orderId, SituationalStatsType.ADD_ORDER);
-	}
-
-	public static SituationalStats createDeleteOrderStats(long orderId) {
-		return new SituationalStats(orderId, SituationalStatsType.DELETE_ORDER);
-	}
-
-	public static SituationalStats createUpdateOrderStats(long orderId) {
-		return new SituationalStats(orderId, SituationalStatsType.UPDATE_ORDER);
-	}
-
-    public static SituationalStats createNotEnoughCreditStats(long orderId) {
-        return new SituationalStats(orderId, SituationalStatsType.NOT_ENOUGH_CREDIT);
-    }
-
-    public static SituationalStats createNotEnoughPositionsStats(long orderId) {
-        return new SituationalStats(orderId, SituationalStatsType.NOT_ENOUGH_POSITIONS);
-    }
-
-    public static SituationalStats createNotEnoughExecutionStats(long orderId) {
-        return new SituationalStats(orderId, SituationalStatsType.NOT_ENOUGH_EXECUTION);
-    }
-
-    public static SituationalStats createOrderActivatedStats(long orderId, long requestId) {
-        return new SituationalStats(orderId, requestId, SituationalStatsType.ORDER_ACTIVATED);
-    }
-
-    public static SituationalStats createExecutionStatsFromUnsuccessfulMatchResult(MatchResult matchResult, long orderId) {
-        switch (matchResult.outcome()) {
-            case MatchingOutcome.NOT_ENOUGH_CREDIT   : return createNotEnoughCreditStats(orderId);
-            case MatchingOutcome.NOT_ENOUGH_POSITIONS: return createNotEnoughPositionsStats(orderId);
-            case MatchingOutcome.NOT_ENOUGH_EXECUTION: return createNotEnoughExecutionStats(orderId);
-            default: throw new IllegalArgumentException("Unknown unsuccessful match result");
-        }
-    }
-
-    public long getRequestId() {
-        if (this.type != SituationalStatsType.ORDER_ACTIVATED) {
-            throw new IllegalStateException("Only order activated stats has requestId.");
-        }
-        return this.requestId;
-    }
-}
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/security_stats/SituationalStatsType.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/security_stats/SituationalStatsType.java
deleted file mode 100644
index 65cc2ef..0000000
--- a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/security_stats/SituationalStatsType.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package ir.ramtung.tinyme.domain.entity.security_stats;
-
-public enum SituationalStatsType {
-    DELETE_ORDER,
-    ADD_ORDER,
-    UPDATE_ORDER,
-    ORDER_ACTIVATED,
-    NOT_ENOUGH_CREDIT,
-    NOT_ENOUGH_POSITIONS,
-    NOT_ENOUGH_EXECUTION
-}
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/security_stats/StateStats.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/security_stats/StateStats.java
deleted file mode 100644
index 2da2a26..0000000
--- a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/security_stats/StateStats.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package ir.ramtung.tinyme.domain.entity.security_stats;
-
-import ir.ramtung.tinyme.domain.entity.SecurityState;
-import lombok.Getter;
-
-@Getter
-public class StateStats extends SecurityStats {
-    private SecurityState from;
-    private SecurityState to;
-    
-    private StateStats(SecurityState from, SecurityState to) {
-        this.from = from;
-        this.to = to;
-    }
-
-    public static StateStats createStateStats(SecurityState from, SecurityState to) {
-        return new StateStats(from, to);
-    }
-}
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/stats/AuctionStats.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/stats/AuctionStats.java
new file mode 100644
index 0000000..c7eab44
--- /dev/null
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/stats/AuctionStats.java
@@ -0,0 +1,19 @@
+package ir.ramtung.tinyme.domain.entity.stats;
+
+import lombok.Getter;
+
+@Getter
+public class AuctionStats extends SecurityStats {
+
+	int openingPrice;
+	int tradableQuantity;
+
+	private AuctionStats(int openingPrice, int tradableQuantity) {
+		this.openingPrice = openingPrice;
+		this.tradableQuantity = tradableQuantity;
+	}
+
+	public static AuctionStats createAuctionStats(int openingPrice, int tradableQuantity) {
+		return new AuctionStats(openingPrice, tradableQuantity);
+	}
+}
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/stats/ExecuteStats.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/stats/ExecuteStats.java
new file mode 100644
index 0000000..70a838f
--- /dev/null
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/stats/ExecuteStats.java
@@ -0,0 +1,77 @@
+package ir.ramtung.tinyme.domain.entity.stats;
+
+import ir.ramtung.tinyme.domain.entity.SecurityState;
+import ir.ramtung.tinyme.domain.entity.Trade;
+import java.util.List;
+import lombok.Getter;
+
+@Getter
+public class ExecuteStats extends SecurityStats {
+
+	private long orderId;
+	private long requestId;
+	private List<Trade> trades;
+	private SecurityState securityState;
+	private boolean isForActivatedOrder;
+
+	private ExecuteStats(long orderId, List<Trade> trades, SecurityState securityState) {
+		this.orderId = orderId;
+		this.trades = trades;
+		this.securityState = securityState;
+		this.isForActivatedOrder = false;
+	}
+
+	private ExecuteStats(
+		long orderId,
+		long requestId,
+		boolean isForActivatedOrder,
+		List<Trade> trades,
+		SecurityState securityState
+	) {
+		this(orderId, trades, securityState);
+		this.requestId = requestId;
+		this.isForActivatedOrder = isForActivatedOrder;
+	}
+
+	public static ExecuteStats createAuctionExecuteStats(List<Trade> trades) {
+		return new ExecuteStats(0, trades, SecurityState.AUCTION);
+	}
+
+	public static ExecuteStats createContinuousExecuteStats(List<Trade> trades, long orderId) {
+		return new ExecuteStats(orderId, trades, SecurityState.CONTINUOUS);
+	}
+
+	public static ExecuteStats createContinuousExecuteStatsForActivatedOrder(
+		List<Trade> trades,
+		long orderId,
+		long requestId
+	) {
+		return new ExecuteStats(orderId, requestId, true, trades, SecurityState.CONTINUOUS);
+	}
+
+	public long getOrderId() {
+		if (securityState == SecurityState.AUCTION) {
+			throw new IllegalStateException("Action execute stats can not have order id");
+		}
+		return this.orderId;
+	}
+
+	public long getRequestId() {
+		if (!isForActivatedOrder) {
+			throw new IllegalStateException("Only order activated execution stats has requestId");
+		}
+		return requestId;
+	}
+
+	public boolean isForActivatedOrder() {
+		return isForActivatedOrder;
+	}
+
+	public boolean isAuction() {
+		return securityState == SecurityState.AUCTION;
+	}
+
+	public boolean isContinuous() {
+		return securityState == SecurityState.CONTINUOUS;
+	}
+}
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/stats/SecurityStats.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/stats/SecurityStats.java
new file mode 100644
index 0000000..733afd1
--- /dev/null
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/stats/SecurityStats.java
@@ -0,0 +1,6 @@
+package ir.ramtung.tinyme.domain.entity.stats;
+
+import lombok.Getter;
+
+@Getter
+public abstract class SecurityStats {}
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/stats/SituationalStats.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/stats/SituationalStats.java
new file mode 100644
index 0000000..7bcbb7a
--- /dev/null
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/stats/SituationalStats.java
@@ -0,0 +1,74 @@
+package ir.ramtung.tinyme.domain.entity.stats;
+
+import ir.ramtung.tinyme.domain.entity.MatchResult;
+import ir.ramtung.tinyme.domain.entity.MatchingOutcome;
+import lombok.Getter;
+
+@Getter
+public class SituationalStats extends SecurityStats {
+
+	private long orderId;
+	private long requestId;
+	private SituationalStatsType type;
+
+	private SituationalStats(long orderId, SituationalStatsType type) {
+		this.orderId = orderId;
+		this.type = type;
+	}
+
+	private SituationalStats(long orderId, long requestId, SituationalStatsType type) {
+		this(orderId, type);
+		this.requestId = requestId;
+	}
+
+	public static SecurityStats createAddOrderStats(long orderId) {
+		return new SituationalStats(orderId, SituationalStatsType.ADD_ORDER);
+	}
+
+	public static SituationalStats createDeleteOrderStats(long orderId) {
+		return new SituationalStats(orderId, SituationalStatsType.DELETE_ORDER);
+	}
+
+	public static SituationalStats createUpdateOrderStats(long orderId) {
+		return new SituationalStats(orderId, SituationalStatsType.UPDATE_ORDER);
+	}
+
+	public static SituationalStats createNotEnoughCreditStats(long orderId) {
+		return new SituationalStats(orderId, SituationalStatsType.NOT_ENOUGH_CREDIT);
+	}
+
+	public static SituationalStats createNotEnoughPositionsStats(long orderId) {
+		return new SituationalStats(orderId, SituationalStatsType.NOT_ENOUGH_POSITIONS);
+	}
+
+	public static SituationalStats createNotEnoughExecutionStats(long orderId) {
+		return new SituationalStats(orderId, SituationalStatsType.NOT_ENOUGH_EXECUTION);
+	}
+
+	public static SituationalStats createOrderActivatedStats(long orderId, long requestId) {
+		return new SituationalStats(orderId, requestId, SituationalStatsType.ORDER_ACTIVATED);
+	}
+
+	public static SituationalStats createExecutionStatsFromUnsuccessfulMatchResult(
+		MatchResult matchResult,
+		long orderId
+	) {
+		switch (matchResult.outcome()) {
+			case MatchingOutcome.NOT_ENOUGH_CREDIT:
+				return createNotEnoughCreditStats(orderId);
+			case MatchingOutcome.NOT_ENOUGH_POSITIONS:
+				return createNotEnoughPositionsStats(orderId);
+			case MatchingOutcome.NOT_ENOUGH_EXECUTION:
+				return createNotEnoughExecutionStats(orderId);
+			default:
+				throw new IllegalArgumentException("Unknown unsuccessful match result");
+		}
+	}
+
+	public long getRequestId() {
+		if (this.type != SituationalStatsType.ORDER_ACTIVATED) {
+			throw new IllegalStateException("Only order activated stats has requestId.");
+		}
+		return this.requestId;
+	}
+}
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/stats/SituationalStatsType.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/stats/SituationalStatsType.java
new file mode 100644
index 0000000..7c4a121
--- /dev/null
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/stats/SituationalStatsType.java
@@ -0,0 +1,11 @@
+package ir.ramtung.tinyme.domain.entity.stats;
+
+public enum SituationalStatsType {
+	DELETE_ORDER,
+	ADD_ORDER,
+	UPDATE_ORDER,
+	ORDER_ACTIVATED,
+	NOT_ENOUGH_CREDIT,
+	NOT_ENOUGH_POSITIONS,
+	NOT_ENOUGH_EXECUTION,
+}
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/stats/StateStats.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/stats/StateStats.java
new file mode 100644
index 0000000..b869b16
--- /dev/null
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/entity/stats/StateStats.java
@@ -0,0 +1,20 @@
+package ir.ramtung.tinyme.domain.entity.stats;
+
+import ir.ramtung.tinyme.domain.entity.SecurityState;
+import lombok.Getter;
+
+@Getter
+public class StateStats extends SecurityStats {
+
+	private SecurityState from;
+	private SecurityState to;
+
+	private StateStats(SecurityState from, SecurityState to) {
+		this.from = from;
+		this.to = to;
+	}
+
+	public static StateStats createStateStats(SecurityState from, SecurityState to) {
+		return new StateStats(from, to);
+	}
+}
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/exception/InvalidRequestFieldAccess.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/exception/InvalidRequestFieldAccess.java
new file mode 100644
index 0000000..2a4ccda
--- /dev/null
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/exception/InvalidRequestFieldAccess.java
@@ -0,0 +1,12 @@
+package ir.ramtung.tinyme.domain.exception;
+
+public class InvalidRequestFieldAccess extends RuntimeException {
+
+	public InvalidRequestFieldAccess() {
+		super("Invalid request field access");
+	}
+
+	public InvalidRequestFieldAccess(String message) {
+		super(message);
+	}
+}
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/ApplicationServiceResponse.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/ApplicationServiceResponse.java
index 063abf2..cfecbb3 100644
--- a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/ApplicationServiceResponse.java
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/ApplicationServiceResponse.java
@@ -1,5 +1,6 @@
 package ir.ramtung.tinyme.domain.service;
 
+import ir.ramtung.tinyme.domain.exception.InvalidRequestFieldAccess;
 import ir.ramtung.tinyme.messaging.event.Event;
 import ir.ramtung.tinyme.messaging.request.BaseOrderRq;
 import java.util.List;
@@ -55,15 +56,17 @@ public class ApplicationServiceResponse {
 		);
 	}
 
-	public long getRequestId() {
-		// Fixme:
-		BaseOrderRq baseOrderRq = (BaseOrderRq) this.req;
-		return baseOrderRq.getRequestId();
+	public long getRequestId() throws InvalidRequestFieldAccess {
+		if (this.req instanceof BaseOrderRq baseOrderRq) {
+			return baseOrderRq.getRequestId();
+		}
+		throw new InvalidRequestFieldAccess();
 	}
 
-	public long getOrderId() {
-		// Fixme:
-		BaseOrderRq baseOrderRq = (BaseOrderRq) this.req;
-		return baseOrderRq.getOrderId();
+	public long getOrderId() throws InvalidRequestFieldAccess {
+		if (this.req instanceof BaseOrderRq baseOrderRq) {
+			return baseOrderRq.getOrderId();
+		}
+		throw new InvalidRequestFieldAccess();
 	}
 }
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/ApplicationServices.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/ApplicationServices.java
index e701eff..246f3f3 100644
--- a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/ApplicationServices.java
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/ApplicationServices.java
@@ -1,12 +1,12 @@
 package ir.ramtung.tinyme.domain.service;
 
 import ir.ramtung.tinyme.domain.entity.*;
-import ir.ramtung.tinyme.domain.entity.security_stats.AuctionStats;
-import ir.ramtung.tinyme.domain.entity.security_stats.ExecuteStats;
-import ir.ramtung.tinyme.domain.entity.security_stats.SecurityStats;
-import ir.ramtung.tinyme.domain.entity.security_stats.SituationalStats;
-import ir.ramtung.tinyme.domain.entity.security_stats.SituationalStatsType;
-import ir.ramtung.tinyme.domain.entity.security_stats.StateStats;
+import ir.ramtung.tinyme.domain.entity.stats.AuctionStats;
+import ir.ramtung.tinyme.domain.entity.stats.ExecuteStats;
+import ir.ramtung.tinyme.domain.entity.stats.SecurityStats;
+import ir.ramtung.tinyme.domain.entity.stats.SituationalStats;
+import ir.ramtung.tinyme.domain.entity.stats.SituationalStatsType;
+import ir.ramtung.tinyme.domain.entity.stats.StateStats;
 import ir.ramtung.tinyme.domain.exception.InvalidIcebergPeakSizeException;
 import ir.ramtung.tinyme.domain.exception.InvalidPeakSizeException;
 import ir.ramtung.tinyme.domain.exception.InvalidStopLimitPriceException;
@@ -33,11 +33,9 @@ import ir.ramtung.tinyme.messaging.request.MatchingState;
 import ir.ramtung.tinyme.repository.BrokerRepository;
 import ir.ramtung.tinyme.repository.SecurityRepository;
 import ir.ramtung.tinyme.repository.ShareholderRepository;
-
 import java.util.ArrayList;
 import java.util.List;
 import java.util.stream.Collectors;
-
 import org.springframework.stereotype.Service;
 
 @Service
@@ -90,8 +88,10 @@ public class ApplicationServices {
 			throw new InvalidRequestException(Message.ORDER_ID_NOT_FOUND);
 		}
 
-		if(security.getState() == SecurityState.AUCTION &&
-				security.isStopLimitOrder(deleteOrderRq.getSide(), deleteOrderRq.getOrderId())) {
+		if (
+			security.getState() == SecurityState.AUCTION &&
+			security.isStopLimitOrder(deleteOrderRq.getSide(), deleteOrderRq.getOrderId())
+		) {
 			throw new InvalidRequestException(Message.CAN_NOT_DELETE_SLO_IN_AUCTION_STATE);
 		}
 	}
@@ -165,33 +165,53 @@ public class ApplicationServices {
 	}
 
 	private Event createOpeningPriceEvent(AuctionStats auctionStats) {
-		return new OpeningPriceEvent(security.getIsin(), auctionStats.getOpeningPrice(), auctionStats.getTradableQuantity());
+		return new OpeningPriceEvent(
+			security.getIsin(),
+			auctionStats.getOpeningPrice(),
+			auctionStats.getTradableQuantity()
+		);
 	}
 
 	private Event createSecurityStateChangedEvent(StateStats stateStats) {
-		MatchingState state = (stateStats.getTo() == SecurityState.AUCTION) ? MatchingState.AUCTION : MatchingState.CONTINUOUS;
+		MatchingState state = (stateStats.getTo() == SecurityState.AUCTION)
+			? MatchingState.AUCTION
+			: MatchingState.CONTINUOUS;
 		return new SecurityStateChangedEvent(security.getIsin(), state);
 	}
 
 	private Event createEventFromSituationalStats(SituationalStats situationalStats, long requestId) {
 		long orderId = situationalStats.getOrderId();
 		switch (situationalStats.getType()) {
-            case SituationalStatsType.DELETE_ORDER         : return new OrderDeletedEvent(requestId, orderId); 
-            case SituationalStatsType.ADD_ORDER            : return new OrderAcceptedEvent(requestId, orderId);
-            case SituationalStatsType.UPDATE_ORDER         : return new OrderUpdatedEvent(requestId, orderId);
-            case SituationalStatsType.ORDER_ACTIVATED      : return new OrderActivatedEvent(orderId);
-            case SituationalStatsType.NOT_ENOUGH_CREDIT    : return new OrderRejectedEvent(requestId, orderId, List.of(Message.BUYER_HAS_NOT_ENOUGH_CREDIT));
-            case SituationalStatsType.NOT_ENOUGH_POSITIONS : return new OrderRejectedEvent(requestId, orderId, List.of(Message.SELLER_HAS_NOT_ENOUGH_POSITIONS));
-            case SituationalStatsType.NOT_ENOUGH_EXECUTION : return new OrderRejectedEvent(requestId, orderId, List.of(Message.MINIMUM_EXECUTION_QUANTITY_NOT_MET));
-            default : throw new UnknownError("Unknown SituationalStatsType");
-        }
+			case SituationalStatsType.DELETE_ORDER:
+				return new OrderDeletedEvent(requestId, orderId);
+			case SituationalStatsType.ADD_ORDER:
+				return new OrderAcceptedEvent(requestId, orderId);
+			case SituationalStatsType.UPDATE_ORDER:
+				return new OrderUpdatedEvent(requestId, orderId);
+			case SituationalStatsType.ORDER_ACTIVATED:
+				return new OrderActivatedEvent(orderId);
+			case SituationalStatsType.NOT_ENOUGH_CREDIT:
+				return new OrderRejectedEvent(requestId, orderId, List.of(Message.BUYER_HAS_NOT_ENOUGH_CREDIT));
+			case SituationalStatsType.NOT_ENOUGH_POSITIONS:
+				return new OrderRejectedEvent(requestId, orderId, List.of(Message.SELLER_HAS_NOT_ENOUGH_POSITIONS));
+			case SituationalStatsType.NOT_ENOUGH_EXECUTION:
+				return new OrderRejectedEvent(requestId, orderId, List.of(Message.MINIMUM_EXECUTION_QUANTITY_NOT_MET));
+			default:
+				throw new UnknownError("Unknown SituationalStatsType");
+		}
 	}
 
 	private List<Event> createEventsFromExecuteStats(ExecuteStats executeStats, long requestId) {
-		if (executeStats.isCountinues()) {
+		if (executeStats.isContinuous()) {
 			long orderId = executeStats.getOrderId();
 			long finalRequestId = (executeStats.isForActivatedOrder()) ? executeStats.getRequestId() : requestId;
-			return List.of(new OrderExecutedEvent(finalRequestId, orderId, executeStats.getTrades().stream().map(TradeDTO::new).collect(Collectors.toList())));
+			return List.of(
+				new OrderExecutedEvent(
+					finalRequestId,
+					orderId,
+					executeStats.getTrades().stream().map(TradeDTO::new).collect(Collectors.toList())
+				)
+			);
 		} else {
 			return createTradeEvents(executeStats);
 		}
@@ -280,7 +300,9 @@ public class ApplicationServices {
 	public ApplicationServiceResponse changeMatchingState(ChangeMatchingStateRq req) {
 		validateChangeMatchingState(req);
 		setEntitiesByRq(req);
-		SecurityState targetSecurityState = (req.getTargetState() == MatchingState.AUCTION) ? SecurityState.AUCTION : SecurityState.CONTINUOUS;
+		SecurityState targetSecurityState = (req.getTargetState() == MatchingState.AUCTION)
+			? SecurityState.AUCTION
+			: SecurityState.CONTINUOUS;
 		SecurityResponse response = security.changeMatchingState(targetSecurityState);
 		List<Event> events = createEventsFormSecurityStats(response.getStats(), 0);
 
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/Matcher.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/Matcher.java
index 6f4588e..5c8b840 100644
--- a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/Matcher.java
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/Matcher.java
@@ -1,10 +1,10 @@
 package ir.ramtung.tinyme.domain.service;
 
 import ir.ramtung.tinyme.domain.entity.*;
-import ir.ramtung.tinyme.domain.exception.NotEnoughCreditException;
-import ir.ramtung.tinyme.domain.exception.NotEnoughExecutionException;
-import ir.ramtung.tinyme.domain.exception.NotFoundException;
-
+import ir.ramtung.tinyme.domain.service.controls.AuctionMatchingControl;
+import ir.ramtung.tinyme.domain.service.controls.ContinuousMatchingControl;
+import ir.ramtung.tinyme.domain.service.controls.ControlResult;
+import ir.ramtung.tinyme.domain.service.controls.MatchingControl;
 import java.util.ArrayList;
 import java.util.LinkedList;
 import java.util.List;
@@ -13,132 +13,211 @@ import org.springframework.stereotype.Service;
 @Service
 public class Matcher {
 
+	private MatchingControl continuousMatchingControl;
+	private MatchingControl auctionMatchingControl;
+
+	public Matcher(ContinuousMatchingControl continuousMatchingControl, AuctionMatchingControl auctionMatchingControl) {
+		this.continuousMatchingControl = continuousMatchingControl;
+		this.auctionMatchingControl = auctionMatchingControl;
+	}
+
 	private boolean hasOrderForAuction(OrderBook orderBook) {
-		return orderBook.hasOrderOfType(Side.BUY) &&
-				orderBook.hasOrderOfType(Side.SELL);
+		return orderBook.hasOrderOfType(Side.BUY) && orderBook.hasOrderOfType(Side.SELL);
 	}
 
 	public int calcOpeningAuctionPrice(OrderBook orderBook, int lastTradePrice) {
-		if(!hasOrderForAuction(orderBook))
+		if (!hasOrderForAuction(orderBook)) {
 			return lastTradePrice;
+		}
 
 		int minPrice = orderBook.getLowestPriorityActiveOrder(Side.BUY).getPrice();
 		int maxPrice = orderBook.getLowestPriorityActiveOrder(Side.SELL).getPrice();
 
 		int maxTradableQuantity = 0;
-		int openingPrice = lastTradePrice; 
-		
+		int openingPrice = lastTradePrice;
+
 		for (int price = minPrice; price <= maxPrice; price++) {
 			int currentTradableQuantity = calcTradableQuantity(orderBook, price);
-			if (currentTradableQuantity > maxTradableQuantity) {
+			if (
+				shouldUpdateOpeningAuctionPrice(
+					openingPrice,
+					price,
+					lastTradePrice,
+					maxTradableQuantity,
+					currentTradableQuantity
+				)
+			) {
 				openingPrice = price;
 				maxTradableQuantity = currentTradableQuantity;
-			} 
-			else if (currentTradableQuantity == maxTradableQuantity && Math.abs(price - lastTradePrice) < Math.abs(openingPrice - lastTradePrice)) {
-				openingPrice = price;
 			}
 		}
-		
+
 		return openingPrice;
 	}
 
+	private boolean shouldUpdateOpeningAuctionPrice(
+		int openingPrice,
+		int newOpeningPrice,
+		int lastTradePrice,
+		int openingTradableQuantity,
+		int newOpeningTradableQuantity
+	) {
+		return (
+			newOpeningTradableQuantity > openingTradableQuantity ||
+			(
+				newOpeningTradableQuantity == openingTradableQuantity &&
+				Math.abs(newOpeningPrice - lastTradePrice) < Math.abs(openingPrice - lastTradePrice)
+			)
+		);
+	}
+
 	public int calcTradableQuantity(OrderBook orderBook, int openingPrice) {
-		int buysQuantity = 0;
-		int sellsQuantity = 0;
+		int buysQuantity = calcTradableQuantityInQueue(orderBook.getBuyQueue(), openingPrice);
+		int sellsQuantity = calcTradableQuantityInQueue(orderBook.getSellQueue(), openingPrice);
+		return Math.min(buysQuantity, sellsQuantity);
+	}
+
+	private int calcTradableQuantityInQueue(List<Order> queue, int price) {
+		return queue.stream().filter(order -> order.canTradeWithPrice(price)).mapToInt(Order::getTotalQuantity).sum();
+	}
+
+	private void controllerMatch(Trade trade, OrderBook orderBook, MatchingControl control, List<Trade> trades) {
+		control.actionAtMatch(trade, orderBook);
+		trades.add(trade);
+	}
 
-		for (Order order : orderBook.getBuyQueue()) {
-			if (order.canTradeWithPrice(openingPrice)) {
-				buysQuantity += order.getTotalQuantity();
-			} 
+	private MatchResult controllerFailedBeforeMatch(
+		MatchingControl control,
+		List<Trade> trades,
+		OrderBook orderBook,
+		ControlResult controlResult
+	) {
+		control.actionAtFailedBeforeMatch(trades, orderBook);
+		return MatchResult.createFromControlResult(controlResult);
+	}
+
+	public MatchResult continuousMatch(Order order, OrderBook orderBook) {
+		List<Trade> trades = new LinkedList<>();
+		ControlResult controlResult;
+		Order matchingOrder;
+
+		while ((matchingOrder = getMatchingOrder(order, orderBook)) != null) {
+			Trade trade = createTradeForContinuousMatching(order, matchingOrder);
+			controlResult = continuousMatchingControl.checkBeforeMatch(trade);
+			
+			if (controlResult == ControlResult.OK) {
+				controllerMatch(trade, orderBook, continuousMatchingControl, trades);
+			} else {
+				return controllerFailedBeforeMatch(continuousMatchingControl, trades, orderBook, controlResult);
+			}
 		}
 
-		for (Order order : orderBook.getSellQueue()) {
-			if (order.canTradeWithPrice(openingPrice)) {
-				sellsQuantity += order.getTotalQuantity();
-			} 
+		controlResult = endMatching(continuousMatchingControl, order, orderBook, trades);
+		if (controlResult != ControlResult.OK) {
+			return MatchResult.createFromControlResult(controlResult);
 		}
 
-		return Math.min(buysQuantity, sellsQuantity);
+		return MatchResult.executed(order, trades);
 	}
 
-	public List<Trade> continuousMatch(Order newOrder) {
-		OrderBook orderBook = newOrder.getSecurity().getOrderBook();
-		LinkedList<Trade> trades = new LinkedList<>();
-		try {
-			while (hasOrderToMatch(newOrder, orderBook)) {
-				Order matchingOrder = orderBook.findOrderToMatchWith(newOrder);
-				if (newOrder.getSide() == Side.SELL) {
-					trades.add(createTrade(newOrder, matchingOrder, matchingOrder.getPrice()));
-				} else {
-					trades.add(createTrade(matchingOrder, newOrder, matchingOrder.getPrice()));
-				}
+	private MatchResult auctionMatch(OrderBook orderBook, int openingPrice) {
+		ControlResult controlResult;
+		List<Trade> trades = new ArrayList<>();
+		Trade currentTrade;
+
+		while ((currentTrade = createTradeForAuctionMatching(orderBook, openingPrice)) != null) {
+			controlResult = auctionMatchingControl.checkBeforeMatch(currentTrade);
+			if (controlResult == ControlResult.OK) {
+				controllerMatch(currentTrade, orderBook, auctionMatchingControl, trades);
+			} else {
+				return controllerFailedBeforeMatch(auctionMatchingControl, trades, orderBook, controlResult);
 			}
-			return trades;
-		} catch (NotFoundException exp) {
-			return trades;
-		} catch (NotEnoughCreditException exp) {
-			rollbackTrades(trades);
-			throw exp;
 		}
+
+		controlResult = endMatching(auctionMatchingControl, null, orderBook, trades);
+		if (controlResult != ControlResult.OK) {
+			return MatchResult.createFromControlResult(controlResult);
+		}
+
+		return MatchResult.executed(null, trades);
 	}
 
-	private List<Trade> auctionMatch(OrderBook orderBook, int openingPrice) {
-		List<Trade> trades = new ArrayList<>();
-		if(!hasOrderForAuction(orderBook)) {
-			return trades;
+	private ControlResult endMatching(
+		MatchingControl control,
+		Order targetOrder,
+		OrderBook orderBook,
+		List<Trade> trades
+	) {
+		ControlResult result = control.checkAfterMatching(targetOrder, trades);
+		if (result == ControlResult.OK) {
+			control.actionAfterMatching(targetOrder, orderBook);
+		} else {
+			control.actionAfterFailedMatching(trades, orderBook);
+		}
+
+		return result;
+	}
+
+	private Trade createTradeForAuctionMatching(OrderBook orderBook, int openingPrice) {
+		if (!hasOrderForAuction(orderBook)) {
+			return null;
 		}
+
 		Order sellOrder = orderBook.getHighestPriorityActiveOrder(Side.SELL);
 		Order buyOrder = orderBook.getHighestPriorityActiveOrder(Side.BUY);
-		while(sellOrder.canTradeWithPrice(openingPrice) && buyOrder.canTradeWithPrice(openingPrice)) {
-			trades.add(createTrade(sellOrder, buyOrder, openingPrice));
-			// FIXME: maybe more clear?
-			if(!hasOrderForAuction(orderBook))
-				break;
-			sellOrder = orderBook.getHighestPriorityActiveOrder(Side.SELL);
-			buyOrder = orderBook.getHighestPriorityActiveOrder(Side.BUY);
+
+		if (sellOrder.canTradeWithPrice(openingPrice) && buyOrder.canTradeWithPrice(openingPrice)) {
+			return new Trade(sellOrder, buyOrder, openingPrice);
+		} else {
+			return null;
 		}
-		return trades;
 	}
 
-	private Trade createTrade(Order sellOrder, Order buyOrder, int price) {
-		Trade trade = new Trade(sellOrder, buyOrder, price);
-		trade.confirm();
-		return trade;
-	}
+	public MatchResult continuousExecuting(Order targetOrder, OrderBook orderBook) {
+		ControlResult controlResult = startingExecution(continuousMatchingControl, targetOrder, orderBook);
 
-	private boolean hasOrderToMatch(Order newOrder, OrderBook orderBook) {
-		return (orderBook.hasOrderOfType(newOrder.getSide().opposite())) && (newOrder.getQuantity() > 0);
-	}
+		if (controlResult != ControlResult.OK) {
+			return MatchResult.createFromControlResult(controlResult);
+		}
 
-	private void rollbackTrades(List<Trade> trades) {
-		trades.reversed().forEach(Trade::rollback);
+		return continuousMatch(targetOrder, orderBook);
 	}
 
-	public MatchResult continuousExecuting(Order order) {
-		List<Trade> trades = new LinkedList<>();
+	public MatchResult auctionExecuting(OrderBook orderBook, int lastTradePrice) {
+		ControlResult controlResult = startingExecution(auctionMatchingControl, null, orderBook);
 		
-		try {
-			trades = continuousMatch(order);
-			order.checkExecutionQuantity(sumOfExecutionQuantity(trades));
-			order.addYourselfToQueue();
-			return MatchResult.executed(order, trades);
-		} catch (NotEnoughCreditException exp) {
-			rollbackTrades(trades);
-			return MatchResult.notEnoughCredit();
-		} catch (NotEnoughExecutionException exp) {
-			rollbackTrades(trades);
-			return MatchResult.notEnoughExecution();
+		if (controlResult != ControlResult.OK) {
+			return MatchResult.createFromControlResult(controlResult);
 		}
-	}
 
-	public List<Trade> auctionExecuting(OrderBook orderBook, int lastTradePrice) {
 		int openingPrice = calcOpeningAuctionPrice(orderBook, lastTradePrice);
 		return auctionMatch(orderBook, openingPrice);
 	}
 
-	private int sumOfExecutionQuantity(List<Trade> trades) {
-		int quantitySum = 0;
-		for (Trade trade : trades) quantitySum += trade.getQuantity();
-		return quantitySum;
+	private ControlResult startingExecution(MatchingControl control, Order targetOrder, OrderBook orderBook) {
+		ControlResult controlResult = control.checkBeforeMatching(targetOrder, orderBook);
+
+		if (controlResult == ControlResult.OK) {
+			control.actionAtBeforeMatching(targetOrder, orderBook);
+		} else {
+			control.actionAtFailedBeforeMatching(targetOrder, orderBook);
+		}
+		
+		return controlResult;
+	}
+
+	private Order getMatchingOrder(Order targetOrder, OrderBook orderBook) {
+		if (targetOrder.getQuantity() == 0) {
+			return null;
+		}
+		return orderBook.findOrderToMatchWith(targetOrder);
+	}
+
+	private Trade createTradeForContinuousMatching(Order targetOrder, Order matchingOrder) {
+		if (targetOrder.isSell()) {
+			return new Trade(targetOrder, matchingOrder, matchingOrder.getPrice());
+		} else {
+			return new Trade(matchingOrder, targetOrder, matchingOrder.getPrice());
+		}
 	}
 }
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/OrderHandler.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/OrderHandler.java
index 9d44969..74049dd 100644
--- a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/OrderHandler.java
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/OrderHandler.java
@@ -29,11 +29,13 @@ public class OrderHandler {
 			ApplicationServiceResponse response = callService(baseRq);
 			publishApplicationServiceResponse(response);
 		} catch (InvalidRequestException ex) {
-			BaseOrderRq baseOrderRq = (BaseOrderRq) baseRq;
-			//FIXME: Add line -1 to fix line +2
-			eventPublisher.publish(
-					new OrderRejectedEvent(baseOrderRq.getRequestId(), baseOrderRq.getOrderId(), ex.getReasons())
-			);
+			if (baseRq instanceof BaseOrderRq baseOrderRq) {
+				eventPublisher.publish(
+						new OrderRejectedEvent(baseOrderRq.getRequestId(), baseOrderRq.getOrderId(), ex.getReasons())
+				);
+			} else {
+				throw ex;
+			}
 		}
 	}
 
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/controls/AuctionMatchingControl.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/controls/AuctionMatchingControl.java
new file mode 100644
index 0000000..f5c5949
--- /dev/null
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/controls/AuctionMatchingControl.java
@@ -0,0 +1,15 @@
+package ir.ramtung.tinyme.domain.service.controls;
+
+import org.springframework.stereotype.Service;
+
+@Service
+public class AuctionMatchingControl extends MatchingControl {
+
+	public AuctionMatchingControl(
+		PositionControl positionControl,
+		CreditControl creditControl,
+		QuantityControl quantityControl
+	) {
+		super(positionControl, creditControl, quantityControl);
+	}
+}
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/controls/ContinuousMatchingControl.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/controls/ContinuousMatchingControl.java
new file mode 100644
index 0000000..db85e4f
--- /dev/null
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/controls/ContinuousMatchingControl.java
@@ -0,0 +1,63 @@
+package ir.ramtung.tinyme.domain.service.controls;
+
+import ir.ramtung.tinyme.domain.entity.Order;
+import ir.ramtung.tinyme.domain.entity.OrderBook;
+import ir.ramtung.tinyme.domain.entity.Trade;
+import java.util.List;
+import org.springframework.stereotype.Service;
+
+@Service
+public class ContinuousMatchingControl extends MatchingControl {
+
+	public ContinuousMatchingControl(
+		PositionControl positionControl,
+		CreditControl creditControl,
+		QuantityControl quantityControl
+	) {
+		super(positionControl, creditControl, quantityControl);
+	}
+
+	@Override
+	public ControlResult checkBeforeMatching(Order targetOrder, OrderBook orderBook) {
+		return positionControl.checkPositionForOrder(targetOrder, orderBook);
+	}
+
+	@Override
+	public ControlResult checkBeforeMatch(Trade trade) {
+		return creditControl.checkCreditForTrade(trade);
+	}
+
+	@Override
+	public void actionAtFailedBeforeMatch(List<Trade> trades, OrderBook orderBook) {
+		rollbackTrades(trades, orderBook);
+	}
+
+	@Override
+	public ControlResult checkAfterMatching(Order targetOrder, List<Trade> trades) {
+		ControlResult controlResult = quantityControl.checkMinimumExecutionQuantity(targetOrder, trades);
+		if (controlResult != ControlResult.OK) {
+			return controlResult;
+		}
+
+		return creditControl.checkCreditForBeingQueued(targetOrder);
+	}
+
+	@Override
+	public void actionAfterMatching(Order targetOrder, OrderBook orderBook) {
+		creditControl.updateCreditForBeingQueued(targetOrder);
+		quantityControl.enqueueOrderToOrderBook(targetOrder, orderBook);
+	}
+
+	@Override
+	public void actionAfterFailedMatching(List<Trade> trades, OrderBook orderBook) {
+		rollbackTrades(trades, orderBook);
+	}
+
+	private void rollbackTrades(List<Trade> trades, OrderBook orderBook) {
+		for (Trade trade : trades.reversed()) {
+			quantityControl.updateQuantitiesAtRollbackTrade(trade, orderBook);
+			creditControl.updateCreditsAtRollbackTrade(trade);
+			positionControl.updatePositionsAtRollbackTrade(trade);
+		}
+	}
+}
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/controls/ControlResult.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/controls/ControlResult.java
new file mode 100644
index 0000000..daee4f6
--- /dev/null
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/controls/ControlResult.java
@@ -0,0 +1,8 @@
+package ir.ramtung.tinyme.domain.service.controls;
+
+public enum ControlResult {
+	OK,
+	NOT_ENOUGH_POSITION,
+	NOT_ENOUGH_CREDIT,
+	NOT_ENOUGH_EXECUTION,
+}
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/controls/CreditControl.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/controls/CreditControl.java
new file mode 100644
index 0000000..b77ba78
--- /dev/null
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/controls/CreditControl.java
@@ -0,0 +1,108 @@
+package ir.ramtung.tinyme.domain.service.controls;
+
+import ir.ramtung.tinyme.domain.entity.Broker;
+import ir.ramtung.tinyme.domain.entity.Order;
+import ir.ramtung.tinyme.domain.entity.Trade;
+import org.springframework.stereotype.Service;
+
+@Service
+public class CreditControl {
+
+	public ControlResult checkCreditForTrade(Trade trade) {
+		if (trade.isBuyQueued()) {
+			return ControlResult.OK;
+		}
+
+		Order targetOrder = trade.getBuy();
+		long value = trade.getTradedValue();
+		Broker broker = targetOrder.getBroker();
+
+		if (broker.hasEnoughCredit(value)) {
+			return ControlResult.OK;
+		} else {
+			return ControlResult.NOT_ENOUGH_CREDIT;
+		}
+	}
+
+	public ControlResult checkCreditForBeingQueued(Order order) {
+		if (order.isSell()) {
+			return ControlResult.OK;
+		}
+
+		long value = order.getValue();
+		Broker broker = order.getBroker();
+
+		if (broker.hasEnoughCredit(value)) {
+			return ControlResult.OK;
+		} else {
+			return ControlResult.NOT_ENOUGH_CREDIT;
+		}
+	}
+
+	public void updateCreditsAtTrade(Trade trade) {
+		updateBuyerCreditAtTrade(trade);
+		updateSellerCreditAtTrade(trade);
+	}
+
+	public void updateCreditsAtRollbackTrade(Trade trade) {
+		updateBuyerCreditAtRollbackTrade(trade);
+		updateSellerCreditAtRollbackTrade(trade);
+	}
+
+	public void updateCreditForBeingQueued(Order targetOrder) {
+		if (targetOrder.isBuy()) {
+			Broker buyerBroker = targetOrder.getBroker();
+			long remainderValue = targetOrder.getValue();
+			buyerBroker.decreaseCreditBy(remainderValue);
+		}
+	}
+
+	public void updateCreditAtDelete(Order order) {
+		if (order.isBuy()) {
+			Broker buyerBroker = order.getBroker();
+			long orderValue = order.getValue();
+			buyerBroker.increaseCreditBy(orderValue);
+		}
+	}
+
+	private void updateBuyerCreditAtTrade(Trade trade) {
+		Order buyOrder = trade.getBuy();
+		Broker buyerBroker = buyOrder.getBroker();
+		long tradeValue = trade.getTradedValue();
+
+		if (!buyOrder.isQueued()) {
+			buyerBroker.decreaseCreditBy(tradeValue);
+		} else {
+			if (trade.getPrice() < buyOrder.getPrice()) {
+				long backCredit = (long) ((buyOrder.getPrice() - trade.getPrice()) * trade.getQuantity());
+				buyOrder.getBroker().increaseCreditBy(backCredit);
+			}
+		}
+	}
+
+	private void updateSellerCreditAtTrade(Trade trade) {
+		Order sellOrder = trade.getSell();
+		Broker sellerBroker = sellOrder.getBroker();
+		long tradeValue = trade.getTradedValue();
+
+		sellerBroker.increaseCreditBy(tradeValue);
+	}
+
+	private void updateBuyerCreditAtRollbackTrade(Trade trade) {
+		Order buyOrder = trade.getBuy();
+		Broker buyerBroker = buyOrder.getBroker();
+		long tradeValue = trade.getTradedValue();
+
+		if (!buyOrder.isQueued()) {
+			buyerBroker.increaseCreditBy(tradeValue);
+		}
+	}
+
+	private void updateSellerCreditAtRollbackTrade(Trade trade) {
+		Order sellOrder = trade.getSell();
+		Broker sellerBroker = sellOrder.getBroker();
+		long tradeValue = trade.getTradedValue();
+
+		sellerBroker.decreaseCreditBy(tradeValue);
+	}
+}
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/controls/MatchingControl.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/controls/MatchingControl.java
new file mode 100644
index 0000000..ae156e4
--- /dev/null
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/controls/MatchingControl.java
@@ -0,0 +1,51 @@
+package ir.ramtung.tinyme.domain.service.controls;
+
+import ir.ramtung.tinyme.domain.entity.Order;
+import ir.ramtung.tinyme.domain.entity.OrderBook;
+import ir.ramtung.tinyme.domain.entity.Trade;
+import java.util.List;
+
+public abstract class MatchingControl {
+
+	protected PositionControl positionControl;
+	protected CreditControl creditControl;
+	protected QuantityControl quantityControl;
+
+	public MatchingControl(
+		PositionControl positionControl,
+		CreditControl creditControl,
+		QuantityControl quantityControl
+	) {
+		this.positionControl = positionControl;
+		this.creditControl = creditControl;
+		this.quantityControl = quantityControl;
+	}
+
+	public ControlResult checkBeforeMatching(Order targetOrder, OrderBook orderBook) {
+		return ControlResult.OK;
+	}
+
+	public void actionAtBeforeMatching(Order targetOrder, OrderBook orderBook) {}
+
+	public void actionAtFailedBeforeMatching(Order targetOrder, OrderBook orderBook) {}
+
+	public ControlResult checkBeforeMatch(Trade trade) {
+		return ControlResult.OK;
+	}
+
+	public void actionAtMatch(Trade trade, OrderBook orderBook) {
+		creditControl.updateCreditsAtTrade(trade);
+		quantityControl.updateQuantitiesAtTrade(trade, orderBook);
+		positionControl.updatePositionsAtTrade(trade);
+	}
+
+	public void actionAtFailedBeforeMatch(List<Trade> trades, OrderBook orderBook) {}
+
+	public ControlResult checkAfterMatching(Order targetOrder, List<Trade> trades) {
+		return ControlResult.OK;
+	}
+
+	public void actionAfterMatching(Order targetOrder, OrderBook orderBook) {}
+
+	public void actionAfterFailedMatching(List<Trade> trades, OrderBook orerrBook) {}
+}
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/controls/PositionControl.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/controls/PositionControl.java
new file mode 100644
index 0000000..015fcb9
--- /dev/null
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/controls/PositionControl.java
@@ -0,0 +1,76 @@
+package ir.ramtung.tinyme.domain.service.controls;
+
+import ir.ramtung.tinyme.domain.entity.Order;
+import ir.ramtung.tinyme.domain.entity.OrderBook;
+import ir.ramtung.tinyme.domain.entity.Security;
+import ir.ramtung.tinyme.domain.entity.Shareholder;
+import ir.ramtung.tinyme.domain.entity.Trade;
+import org.springframework.stereotype.Service;
+
+@Service
+public class PositionControl {
+
+	public ControlResult checkPositionForOrder(Order order, OrderBook orderBook) {
+		if (order.isBuy()) {
+			return ControlResult.OK;
+		}
+
+		Shareholder shareholder = order.getShareholder();
+		Security security = order.getSecurity();
+		int salesAmount = order.getQuantity();
+		int queuedPositionAmount = orderBook.totalSellQuantityByShareholder(shareholder);
+		int totalNeededPosition = salesAmount + queuedPositionAmount;
+
+		if (shareholder.hasEnoughPositionsOn(security, totalNeededPosition)) {
+			return ControlResult.OK;
+		} else {
+			return ControlResult.NOT_ENOUGH_POSITION;
+		}
+	}
+
+	public void updatePositionsAtTrade(Trade trade) {
+		updateBuyerPositionAtTrade(trade);
+		updateSellerPositionAtTrade(trade);
+	}
+
+	public void updatePositionsAtRollbackTrade(Trade trade) {
+		updateBuyerPositionAtRollbackTrade(trade);
+		updateSellerPositionAtRollbackTrade(trade);
+	}
+
+	private void updateBuyerPositionAtTrade(Trade trade) {
+		Order buyOrder = trade.getBuy();
+		Shareholder buyerShareholder = buyOrder.getShareholder();
+		int tradeQuantity = trade.getQuantity();
+		Security security = trade.getSecurity();
+
+		buyerShareholder.incPosition(security, tradeQuantity);
+	}
+
+	private void updateSellerPositionAtTrade(Trade trade) {
+		Order sellOrder = trade.getSell();
+		Shareholder sellerShareholder = sellOrder.getShareholder();
+		int tradeQuantity = trade.getQuantity();
+		Security security = trade.getSecurity();
+
+		sellerShareholder.decPosition(security, tradeQuantity);
+	}
+
+	private void updateBuyerPositionAtRollbackTrade(Trade trade) {
+		Order buyOrder = trade.getBuy();
+		Shareholder buyerShareholder = buyOrder.getShareholder();
+		Security security = buyOrder.getSecurity();
+		int tradeQuantity = trade.getQuantity();
+
+		buyerShareholder.decPosition(security, tradeQuantity);
+	}
+
+	private void updateSellerPositionAtRollbackTrade(Trade trade) {
+		Order sellOrder = trade.getSell();
+		Shareholder sellerShareholder = sellOrder.getShareholder();
+		Security security = sellOrder.getSecurity();
+		int tradeQuantity = trade.getQuantity();
+
+		sellerShareholder.incPosition(security, tradeQuantity);
+	}
+}
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/controls/QuantityControl.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/controls/QuantityControl.java
new file mode 100644
index 0000000..6fd2606
--- /dev/null
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/controls/QuantityControl.java
@@ -0,0 +1,108 @@
+package ir.ramtung.tinyme.domain.service.controls;
+
+import ir.ramtung.tinyme.domain.entity.IcebergOrder;
+import ir.ramtung.tinyme.domain.entity.Order;
+import ir.ramtung.tinyme.domain.entity.OrderBook;
+import ir.ramtung.tinyme.domain.entity.Trade;
+import java.time.LocalDateTime;
+import java.util.List;
+import org.springframework.stereotype.Service;
+
+@Service
+public class QuantityControl {
+
+	public ControlResult checkMinimumExecutionQuantity(Order order, List<Trade> trades) {
+		if (!order.isNew()) {
+			return ControlResult.OK;
+		}
+
+		int executedQuantity = calcExecutedQuantity(trades);
+		if (order.isMinimumExecuteQuantitySatisfied(executedQuantity)) {
+			return ControlResult.OK;
+		} else {
+			return ControlResult.NOT_ENOUGH_EXECUTION;
+		}
+	}
+
+	public void updateQuantitiesAtTrade(Trade trade, OrderBook orderBook) {
+		updateBuyQuantityAtTrade(trade, orderBook);
+		updateSellQuantityAtTrade(trade, orderBook);
+	}
+
+	public void updateQuantitiesAtRollbackTrade(Trade trade, OrderBook orderBook) {
+		updateBuyQuantityAtRollbackTrade(trade, orderBook);
+		updateSellQuantityAtRollbackTrade(trade, orderBook);
+	}
+
+	public void enqueueOrderToOrderBook(Order targetOrder, OrderBook orderBook) {
+		if (targetOrder instanceof IcebergOrder icebergOrder) {
+			icebergOrder.replenish();
+		}
+		if (targetOrder.getTotalQuantity() != 0) {
+			orderBook.enqueue(targetOrder);
+		}
+	}
+
+	private int calcExecutedQuantity(List<Trade> trades) {
+		int executedQuantity = 0;
+		for (Trade trade : trades) executedQuantity += trade.getQuantity();
+		return executedQuantity;
+	}
+
+	private void updateBuyQuantityAtTrade(Trade trade, OrderBook orderBook) {
+		Order buyOrder = trade.getBuy();
+		int tradeQuantity = trade.getQuantity();
+
+		buyOrder.decreaseQuantity(tradeQuantity);
+		checkQuantityForUnqueued(buyOrder, orderBook);
+	}
+
+	private void updateSellQuantityAtTrade(Trade trade, OrderBook orderBook) {
+		Order sellOrder = trade.getSell();
+		int tradeQuantity = trade.getQuantity();
+
+		sellOrder.decreaseQuantity(tradeQuantity);
+		checkQuantityForUnqueued(sellOrder, orderBook);
+	}
+
+	private void checkQuantityForUnqueued(Order order, OrderBook orderBook) {
+		if (order instanceof IcebergOrder icebergOrder) {
+			checkIcebergQuantityForReplenish(icebergOrder, orderBook);
+		}
+
+		if (order.isDone()) {
+			orderBook.removeOrder(order);
+		}
+	}
+
+	private void checkIcebergQuantityForReplenish(IcebergOrder icebergOrder, OrderBook orderBook) {
+		if (icebergOrder.isDisplayZero() && !icebergOrder.isDone()) {
+			orderBook.removeOrder(icebergOrder);
+			icebergOrder.replenish();
+			icebergOrder.addUpdateTime(LocalDateTime.now());
+			orderBook.enqueue(icebergOrder);
+		}
+	}
+
+	private void updateBuyQuantityAtRollbackTrade(Trade trade, OrderBook orderBook) {
+		Order buyOrder = trade.getBuy();
+		Order originalBuyOrder = trade.getBuyFirstVersion();
+
+		checkQuantityForEnqueue(buyOrder, orderBook);
+		buyOrder.rollback(originalBuyOrder);
+	}
+
+	private void updateSellQuantityAtRollbackTrade(Trade trade, OrderBook orderBook) {
+		Order sellOrder = trade.getSell();
+		Order originalSellOrder = trade.getSellFirstVersion();
+
+		checkQuantityForEnqueue(sellOrder, orderBook);
+		sellOrder.rollback(originalSellOrder);
+	}
+
+	private void checkQuantityForEnqueue(Order order, OrderBook orderBook) {
+		if (order.isDeleted()) {
+			orderBook.enqueue(order);
+		}
+	}
+}
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/security_state/AuctionBehave.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/security_state/AuctionBehave.java
new file mode 100644
index 0000000..de2fe00
--- /dev/null
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/security_state/AuctionBehave.java
@@ -0,0 +1,175 @@
+package ir.ramtung.tinyme.domain.service.security_state;
+
+import ir.ramtung.tinyme.domain.entity.Order;
+import ir.ramtung.tinyme.domain.entity.OrderBook;
+import ir.ramtung.tinyme.domain.entity.SecurityState;
+import ir.ramtung.tinyme.domain.entity.StopLimitOrder;
+import ir.ramtung.tinyme.domain.entity.Trade;
+import ir.ramtung.tinyme.domain.entity.stats.AuctionStats;
+import ir.ramtung.tinyme.domain.entity.stats.ExecuteStats;
+import ir.ramtung.tinyme.domain.entity.stats.SecurityStats;
+import ir.ramtung.tinyme.domain.entity.stats.SituationalStats;
+import ir.ramtung.tinyme.domain.entity.stats.StateStats;
+import ir.ramtung.tinyme.domain.service.Matcher;
+import ir.ramtung.tinyme.domain.service.controls.ControlResult;
+import ir.ramtung.tinyme.domain.service.controls.CreditControl;
+import ir.ramtung.tinyme.domain.service.controls.PositionControl;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import org.springframework.stereotype.Service;
+
+@Service
+public class AuctionBehave implements SecurityBehave {
+
+	private PositionControl positionControl;
+	private CreditControl creditControl;
+	private Matcher matcher;
+
+	public AuctionBehave(PositionControl positionControl, CreditControl creditControl, Matcher matcher) {
+		this.positionControl = positionControl;
+		this.creditControl = creditControl;
+		this.matcher = matcher;
+	}
+
+	@Override
+	public List<SecurityStats> addNewOrder(Order newOrder, OrderBook orderBook, int lastTradePrice) {
+		if (positionControl.checkPositionForOrder(newOrder, orderBook) != ControlResult.OK) {
+			return createNotEnoughPositionsStats(newOrder);
+		}
+		if (creditControl.checkCreditForBeingQueued(newOrder) != ControlResult.OK) {
+			return createNotEnoughCreditStats(newOrder);
+		}
+
+		creditControl.updateCreditForBeingQueued(newOrder);
+		orderBook.enqueue(newOrder);
+
+		List<SecurityStats> stats = new ArrayList<>();
+		stats.add(SituationalStats.createAddOrderStats(newOrder.getOrderId()));
+		stats.add(createAuctionStats(orderBook, lastTradePrice));
+		return stats;
+	}
+
+	@Override
+	public List<SecurityStats> updateOrder(Order tempOrder, Order mainOrder, OrderBook orderBook, int lastTradePrice) {
+		boolean losesPriority = mainOrder.willPriorityLostInUpdate(tempOrder);
+		if (losesPriority) {
+			Order originalOrder = mainOrder.snapshot();
+			creditControl.updateCreditAtDelete(mainOrder);
+			orderBook.removeOrder(mainOrder);
+			mainOrder.updateFromTempOrder(tempOrder);
+			return reAddUpdatedOrder(mainOrder, originalOrder, orderBook, lastTradePrice);
+		} else {
+			return updateByKeepingPriority(tempOrder, mainOrder, orderBook, lastTradePrice);
+		}
+	}
+
+	@Override
+	public List<SecurityStats> deleteOrder(Order targetOrder, OrderBook orderBook, int lastTradePrice) {
+		creditControl.updateCreditAtDelete(targetOrder);
+		orderBook.removeOrder(targetOrder);
+
+		List<SecurityStats> stats = new ArrayList<>();
+		stats.add(SituationalStats.createDeleteOrderStats(targetOrder.getOrderId()));
+		stats.add(createAuctionStats(orderBook, lastTradePrice));
+		return stats;
+	}
+
+	@Override
+	public List<SecurityStats> activateStopLimitOrders(OrderBook orderBook, int lastTradePrice) {
+		List<SecurityStats> stats = new LinkedList<>();
+		StopLimitOrder slo;
+
+		while ((slo = orderBook.getStopLimitOrder(lastTradePrice)) != null) {
+			stats.add(SituationalStats.createOrderActivatedStats(slo.getOrderId(), slo.getRequestId()));
+			Order activatedOrder = new Order(slo);
+			orderBook.enqueue(activatedOrder);
+		}
+
+		return stats;
+	}
+
+	@Override
+	public List<SecurityStats> changeMatchingState(OrderBook orderBook, int lastTradePrice, SecurityState newState) {
+		List<SecurityStats> stats = openAuction(orderBook, lastTradePrice);
+		stats.add(StateStats.createStateStats(SecurityState.AUCTION, newState));
+		return stats;
+	}
+
+	private AuctionStats createAuctionStats(OrderBook orderBook, int lastTradePrice) {
+		int openingPrice = matcher.calcOpeningAuctionPrice(orderBook, lastTradePrice);
+		int tradableQuantity = matcher.calcTradableQuantity(orderBook, openingPrice);
+		return AuctionStats.createAuctionStats(openingPrice, tradableQuantity);
+	}
+
+	private List<SecurityStats> openAuction(OrderBook orderBook, int lastTradePrice) {
+		List<SecurityStats> stats = new ArrayList<>();
+
+		List<Trade> trades = matcher.auctionExecuting(orderBook, lastTradePrice).trades();
+		if (!trades.isEmpty()) {
+			stats.add(ExecuteStats.createAuctionExecuteStats(trades));
+		}
+
+		return stats;
+	}
+
+	private List<SecurityStats> reAddUpdatedOrder(Order updatedOrder, Order originalOrder, 
+												  OrderBook orderBook, int lastTradePrice) {
+													
+		if (positionControl.checkPositionForOrder(updatedOrder, orderBook) != ControlResult.OK) {
+			return handleNotEnoughPositions(originalOrder, orderBook);
+		}
+		
+		if (creditControl.checkCreditForBeingQueued(updatedOrder) != ControlResult.OK) {
+			return handleNotEnoughCredit(originalOrder, orderBook);
+		}
+
+		return handleUpdateOrder(updatedOrder, originalOrder, orderBook, lastTradePrice);
+	}
+
+	private List<SecurityStats> handleUpdateOrder(Order updatedOrder, Order originalOrder, OrderBook orderBook,
+			int lastTradePrice) {
+		creditControl.updateCreditForBeingQueued(updatedOrder);
+		orderBook.enqueue(updatedOrder);
+
+		return createUpdateStats(originalOrder, orderBook, lastTradePrice);
+	}
+
+	private List<SecurityStats> createUpdateStats(Order originalOrder, OrderBook orderBook, int lastTradePrice) {
+		List<SecurityStats> stats = new LinkedList<>();
+		stats.add(SituationalStats.createUpdateOrderStats(originalOrder.getOrderId()));
+		stats.add(createAuctionStats(orderBook, lastTradePrice));
+		return stats;
+	}
+
+	private List<SecurityStats> handleNotEnoughCredit(Order originalOrder, OrderBook orderBook) {
+		creditControl.updateCreditForBeingQueued(originalOrder);
+		orderBook.enqueue(originalOrder);
+		return createNotEnoughCreditStats(originalOrder);
+	}
+
+	private List<SecurityStats> createNotEnoughCreditStats(Order originalOrder) {
+		return new ArrayList<SecurityStats>(
+			List.of(SituationalStats.createNotEnoughCreditStats(originalOrder.getOrderId()))
+		);
+	}
+
+	private List<SecurityStats> handleNotEnoughPositions(Order originalOrder, OrderBook orderBook) {
+		creditControl.updateCreditForBeingQueued(originalOrder);
+		orderBook.enqueue(originalOrder);
+		return createNotEnoughPositionsStats(originalOrder);
+	}
+
+	private List<SecurityStats> createNotEnoughPositionsStats(Order originalOrder) {
+		return new ArrayList<SecurityStats>(
+			List.of(SituationalStats.createNotEnoughPositionsStats(originalOrder.getOrderId()))
+		);
+	}
+
+	private List<SecurityStats> updateByKeepingPriority(Order tempOrder, Order mainOrder, 
+														OrderBook orderBook, int lastTradePrice) {
+
+		mainOrder.updateFromTempOrder(tempOrder);
+		return createUpdateStats(mainOrder, orderBook, lastTradePrice);
+	}
+}
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/security_state/ContinuousBehave.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/security_state/ContinuousBehave.java
new file mode 100644
index 0000000..c3915f1
--- /dev/null
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/security_state/ContinuousBehave.java
@@ -0,0 +1,202 @@
+package ir.ramtung.tinyme.domain.service.security_state;
+
+import ir.ramtung.tinyme.domain.entity.MatchResult;
+import ir.ramtung.tinyme.domain.entity.Order;
+import ir.ramtung.tinyme.domain.entity.OrderBook;
+import ir.ramtung.tinyme.domain.entity.SecurityState;
+import ir.ramtung.tinyme.domain.entity.StopLimitOrder;
+import ir.ramtung.tinyme.domain.entity.stats.ExecuteStats;
+import ir.ramtung.tinyme.domain.entity.stats.SecurityStats;
+import ir.ramtung.tinyme.domain.entity.stats.SituationalStats;
+import ir.ramtung.tinyme.domain.entity.stats.StateStats;
+import ir.ramtung.tinyme.domain.service.Matcher;
+import ir.ramtung.tinyme.domain.service.controls.ControlResult;
+import ir.ramtung.tinyme.domain.service.controls.CreditControl;
+import ir.ramtung.tinyme.domain.service.controls.PositionControl;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import org.springframework.stereotype.Service;
+
+@Service
+public class ContinuousBehave implements SecurityBehave {
+
+	private PositionControl positionControl;
+	private CreditControl creditControl;
+	private Matcher matcher;
+
+	public ContinuousBehave(PositionControl positionControl, CreditControl creditControl, Matcher matcher) {
+		this.positionControl = positionControl;
+		this.creditControl = creditControl;
+		this.matcher = matcher;
+	}
+
+	@Override
+	public List<SecurityStats> addNewOrder(Order newOrder, OrderBook orderBook, int lastTradePrice) {
+		if (positionControl.checkPositionForOrder(newOrder, orderBook) != ControlResult.OK) {
+			return new ArrayList<SecurityStats>(
+				List.of(SituationalStats.createNotEnoughPositionsStats(newOrder.getOrderId()))
+			);
+		}
+
+		if (newOrder instanceof StopLimitOrder newStopLimitOrder) {
+			return addNewStopLimitOrder(newStopLimitOrder, orderBook);
+		} else {
+			return addNewLimitOrder(newOrder, orderBook);
+		}
+	}
+
+	@Override
+	public List<SecurityStats> updateOrder(Order tempOrder, Order mainOrder, OrderBook orderBook, int lastTradePrice) {
+		boolean losesPriority = mainOrder.willPriorityLostInUpdate(tempOrder);
+		if (losesPriority) {
+			Order originalOrder = mainOrder.snapshot();
+			creditControl.updateCreditAtDelete(mainOrder);
+			orderBook.removeOrder(mainOrder);
+			mainOrder.updateFromTempOrder(tempOrder);
+			return reAddUpdatedOrder(mainOrder, originalOrder, orderBook);
+		} else {
+			mainOrder.updateFromTempOrder(tempOrder);
+			return new ArrayList<SecurityStats>(
+				List.of(SituationalStats.createUpdateOrderStats(mainOrder.getOrderId()))
+			);
+		}
+	}
+
+	@Override
+	public List<SecurityStats> deleteOrder(Order targetOrder, OrderBook orderBook, int lastTradePrice) {
+		creditControl.updateCreditAtDelete(targetOrder);
+		orderBook.removeOrder(targetOrder);
+		return new ArrayList<SecurityStats>(List.of(SituationalStats.createDeleteOrderStats(targetOrder.getOrderId())));
+	}
+
+	@Override
+	public List<SecurityStats> activateStopLimitOrders(OrderBook orderBook, int lastTradePrice) {
+		List<SecurityStats> stats = new LinkedList<>();
+		StopLimitOrder slo;
+		int currentLastTradePrice = lastTradePrice;
+
+		slo = orderBook.getStopLimitOrder(currentLastTradePrice);
+
+		while (slo != null) {
+			creditControl.updateCreditAtDelete(slo);
+			stats.add(SituationalStats.createOrderActivatedStats(slo.getOrderId(), slo.getRequestId()));
+			Order activatedOrder = new Order(slo);
+			MatchResult result = matcher.continuousExecuting(activatedOrder, orderBook);
+			if (!result.trades().isEmpty()) {
+				stats.add(
+					ExecuteStats.createContinuousExecuteStatsForActivatedOrder(
+						result.trades(),
+						activatedOrder.getOrderId(),
+						slo.getRequestId()
+					)
+				);
+				currentLastTradePrice = result.trades().getLast().getPrice();
+			}
+			slo = orderBook.getStopLimitOrder(currentLastTradePrice);
+		}
+
+		return stats;
+	}
+
+	@Override
+	public List<SecurityStats> changeMatchingState(OrderBook orderBook, int lastTradePrice, SecurityState newState) {
+		return new ArrayList<SecurityStats>(List.of(StateStats.createStateStats(SecurityState.CONTINUOUS, newState)));
+	}
+
+	private List<SecurityStats> addNewStopLimitOrder(StopLimitOrder newOrder, OrderBook orderBook) {
+		if (creditControl.checkCreditForBeingQueued(newOrder) != ControlResult.OK) {
+			return new ArrayList<SecurityStats>(
+				List.of(SituationalStats.createNotEnoughCreditStats(newOrder.getOrderId()))
+			);
+		}
+
+		creditControl.updateCreditForBeingQueued(newOrder);
+		orderBook.enqueue(newOrder);
+		return new ArrayList<SecurityStats>(List.of(SituationalStats.createAddOrderStats(newOrder.getOrderId())));
+	}
+
+	private List<SecurityStats> addNewLimitOrder(Order newOrder, OrderBook orderBook) {
+		List<SecurityStats> stats = new ArrayList<>();
+		stats.add(SituationalStats.createAddOrderStats(newOrder.getOrderId()));
+
+		MatchResult newOrderMatchResult = matcher.continuousExecuting(newOrder, orderBook);
+		if (!newOrderMatchResult.isSuccessful()) {
+			stats.set(
+				0,
+				SituationalStats.createExecutionStatsFromUnsuccessfulMatchResult(
+					newOrderMatchResult,
+					newOrder.getOrderId()
+				)
+			);
+		}
+		if (!newOrderMatchResult.trades().isEmpty()) {
+			stats.add(ExecuteStats.createContinuousExecuteStats(newOrderMatchResult.trades(), newOrder.getOrderId()));
+		}
+		return stats;
+	}
+
+	private List<SecurityStats> reAddUpdatedOrder(Order updatedOrder, Order originalOrder, OrderBook orderBook) {
+		if (positionControl.checkPositionForOrder(updatedOrder, orderBook) != ControlResult.OK) {
+			creditControl.updateCreditForBeingQueued(originalOrder);
+			orderBook.enqueue(originalOrder);
+			return new ArrayList<SecurityStats>(
+				List.of(SituationalStats.createNotEnoughPositionsStats(originalOrder.getOrderId()))
+			);
+		}
+
+		if (updatedOrder instanceof StopLimitOrder updatedSlo) {
+			StopLimitOrder originalSlo = (StopLimitOrder) originalOrder;
+			return reAddUpdatedSlo(updatedSlo, originalSlo, orderBook);
+		} else {
+			return reAddActiveOrder(updatedOrder, originalOrder, orderBook);
+		}
+	}
+
+	private List<SecurityStats> reAddUpdatedSlo(
+		StopLimitOrder updatedOrder,
+		StopLimitOrder originalOrder,
+		OrderBook orderBook
+	) {
+		if (creditControl.checkCreditForBeingQueued(updatedOrder) != ControlResult.OK) {
+			creditControl.updateCreditForBeingQueued(originalOrder);
+			orderBook.enqueue(originalOrder);
+			return new ArrayList<SecurityStats>(
+				List.of(SituationalStats.createNotEnoughCreditStats(originalOrder.getOrderId()))
+			);
+		}
+
+		creditControl.updateCreditForBeingQueued(updatedOrder);
+		orderBook.enqueue(updatedOrder);
+
+		List<SecurityStats> stats = new LinkedList<>();
+		stats.add(SituationalStats.createUpdateOrderStats(originalOrder.getOrderId()));
+		return stats;
+	}
+
+	private List<SecurityStats> reAddActiveOrder(Order updatedOrder, Order originalOrder, OrderBook orderBook) {
+		List<SecurityStats> stats = new LinkedList<>();
+		stats.add(SituationalStats.createUpdateOrderStats(originalOrder.getOrderId()));
+
+		MatchResult updatedOrderResult = matcher.continuousExecuting(updatedOrder, orderBook);
+
+		if (!updatedOrderResult.isSuccessful()) {
+			creditControl.updateCreditForBeingQueued(originalOrder);
+			orderBook.enqueue(originalOrder);
+			stats.set(
+				0,
+				SituationalStats.createExecutionStatsFromUnsuccessfulMatchResult(
+					updatedOrderResult,
+					originalOrder.getOrderId()
+				)
+			);
+		}
+		if (!updatedOrderResult.trades().isEmpty()) {
+			stats.add(
+				ExecuteStats.createContinuousExecuteStats(updatedOrderResult.trades(), originalOrder.getOrderId())
+			);
+		}
+
+		return stats;
+	}
+}
diff --git a/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/security_state/SecurityBehave.java b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/security_state/SecurityBehave.java
new file mode 100644
index 0000000..b688358
--- /dev/null
+++ b/TinyME_v2.0/src/main/java/ir/ramtung/tinyme/domain/service/security_state/SecurityBehave.java
@@ -0,0 +1,16 @@
+package ir.ramtung.tinyme.domain.service.security_state;
+
+import java.util.List;
+
+import ir.ramtung.tinyme.domain.entity.Order;
+import ir.ramtung.tinyme.domain.entity.OrderBook;
+import ir.ramtung.tinyme.domain.entity.SecurityState;
+import ir.ramtung.tinyme.domain.entity.stats.SecurityStats;
+
+public interface SecurityBehave {
+    public List<SecurityStats> addNewOrder(Order newOrder, OrderBook orderBook, int lastTradePrice);
+    public List<SecurityStats> updateOrder(Order tempOrder, Order mainOrder, OrderBook orderBook, int lastTradePrice);
+    public List<SecurityStats> deleteOrder(Order targetOrder, OrderBook orderBook, int lastTradePrice);
+    public List<SecurityStats> activateStopLimitOrders(OrderBook orderBook, int lastTradePrice);
+    public List<SecurityStats> changeMatchingState(OrderBook orderBook, int lastTradePrice, SecurityState newState);
+}
diff --git a/TinyME_v2.0/src/test/java/ir/ramtung/tinyme/domain/MatcherTest.java b/TinyME_v2.0/src/test/java/ir/ramtung/tinyme/domain/MatcherTest.java
index 89e9d4f..5e9da2e 100644
--- a/TinyME_v2.0/src/test/java/ir/ramtung/tinyme/domain/MatcherTest.java
+++ b/TinyME_v2.0/src/test/java/ir/ramtung/tinyme/domain/MatcherTest.java
@@ -55,7 +55,7 @@ public class MatcherTest {
 	void new_sell_order_matches_completely_with_part_of_the_first_buy() {
 		Order order = new Order(11, security, Side.SELL, 100, 15600, broker, shareholder);
 		Trade trade = new Trade(security, 15700, 100, orders.get(0), order);
-		List<Trade> trades = matcher.continuousMatch(order);
+		List<Trade> trades = matcher.continuousMatch(order, orderBook).trades();
 		assertThat(order.getQuantity()).isEqualTo(0);
 		assertThat(trades).containsExactly(trade);
 		assertThat(security.getOrderBook().getBuyQueue().getFirst().getQuantity()).isEqualTo(204);
@@ -65,7 +65,7 @@ public class MatcherTest {
 	void new_sell_order_matches_partially_with_the_first_buy() {
 		Order order = new Order(11, security, Side.SELL, 500, 15600, broker, shareholder);
 		Trade trade = new Trade(security, 15700, 304, orders.get(0), order);
-		List<Trade> trades = matcher.continuousMatch(order);
+		List<Trade> trades = matcher.continuousMatch(order, orderBook).trades();
 		assertThat(order.getQuantity()).isEqualTo(196);
 		assertThat(trades).containsExactly(trade);
 		assertThat(security.getOrderBook().getBuyQueue().getFirst().getOrderId()).isEqualTo(2);
@@ -74,7 +74,7 @@ public class MatcherTest {
 	@Test
 	void new_buy_order_does_not_match() {
 		Order order = new Order(11, security, Side.BUY, 2000, 15500, broker, shareholder);
-		List<Trade> trades = matcher.continuousMatch(order);
+		List<Trade> trades = matcher.continuousMatch(order, orderBook).trades();
 		assertThat(order).isEqualTo(order);
 		assertThat(trades).isEmpty();
 	}
diff --git a/TinyME_v2.0/src/test/java/ir/ramtung/tinyme/domain/OrderHandlerTest.java b/TinyME_v2.0/src/test/java/ir/ramtung/tinyme/domain/OrderHandlerTest.java
index f600339..3617bcf 100644
--- a/TinyME_v2.0/src/test/java/ir/ramtung/tinyme/domain/OrderHandlerTest.java
+++ b/TinyME_v2.0/src/test/java/ir/ramtung/tinyme/domain/OrderHandlerTest.java
@@ -281,7 +281,6 @@ public class OrderHandlerTest {
 			new Order(1, security, Side.BUY, 20, 15, broker1, shareholder),
 			new Order(7, security, Side.SELL, 10, 20, broker2, shareholder)
 		);
-		broker1.increaseCreditBy(400);
 		orders.forEach(order -> security.getOrderBook().enqueue(order));
 		shareholder.incPosition(security, 10);
 
@@ -1041,7 +1040,6 @@ public class OrderHandlerTest {
 
 	@Test
 	void increase_quantity_stop_limit_order_quantity_not_enough_credit() {
-		broker1.increaseCreditBy(4000);
 		StopLimitOrder order = new StopLimitOrder(6, security, Side.BUY, 10, 400, broker1, shareholder, 500);
 		security.getOrderBook().enqueue(order);
 
@@ -1066,7 +1064,6 @@ public class OrderHandlerTest {
 
 	@Test
 	void increase_price_stop_limit_order_quantity_not_enough_credit() {
-		broker1.increaseCreditBy(4000);
 		StopLimitOrder order = new StopLimitOrder(6, security, Side.BUY, 10, 400, broker1, shareholder, 500);
 		security.getOrderBook().enqueue(order);
 
diff --git a/TinyME_v2.0/src/test/java/ir/ramtung/tinyme/domain/entity/SecurityTest.java b/TinyME_v2.0/src/test/java/ir/ramtung/tinyme/domain/entity/SecurityTest.java
index 11be199..dd9a148 100644
--- a/TinyME_v2.0/src/test/java/ir/ramtung/tinyme/domain/entity/SecurityTest.java
+++ b/TinyME_v2.0/src/test/java/ir/ramtung/tinyme/domain/entity/SecurityTest.java
@@ -3,12 +3,12 @@ package ir.ramtung.tinyme.domain.entity;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 
-import ir.ramtung.tinyme.domain.entity.security_stats.AuctionStats;
-import ir.ramtung.tinyme.domain.entity.security_stats.ExecuteStats;
-import ir.ramtung.tinyme.domain.entity.security_stats.SecurityStats;
-import ir.ramtung.tinyme.domain.entity.security_stats.SituationalStats;
-import ir.ramtung.tinyme.domain.entity.security_stats.SituationalStatsType;
-import ir.ramtung.tinyme.domain.entity.security_stats.StateStats;
+import ir.ramtung.tinyme.domain.entity.stats.AuctionStats;
+import ir.ramtung.tinyme.domain.entity.stats.ExecuteStats;
+import ir.ramtung.tinyme.domain.entity.stats.SecurityStats;
+import ir.ramtung.tinyme.domain.entity.stats.SituationalStats;
+import ir.ramtung.tinyme.domain.entity.stats.SituationalStatsType;
+import ir.ramtung.tinyme.domain.entity.stats.StateStats;
 import ir.ramtung.tinyme.domain.exception.NotFoundException;
 
 import java.time.LocalDateTime;
@@ -119,10 +119,10 @@ public class SecurityTest {
 
 		private void assertAuctionStats(AuctionStats stats, int openingPrice, int tradableQuantity) {
 			int actualOpeningPrice = stats.getOpeningPrice();
-			int acutalTradableQuantity = stats.getTradableQuantity();
+			int actualTradableQuantity = stats.getTradableQuantity();
 
 			assertThat(actualOpeningPrice).isEqualTo(openingPrice);
-			assertThat(acutalTradableQuantity).isEqualTo(tradableQuantity);
+			assertThat(actualTradableQuantity).isEqualTo(tradableQuantity);
 		}
 
 		private void assertSituationalStats(SituationalStats stats, SituationalStatsType type, long orderId) {
@@ -1457,7 +1457,7 @@ public class SecurityTest {
 	void setup() {
 		security = Security.builder().lastTradePrice(550).build();
 		sellerBroker = Broker.builder().credit(0).build();
-		buyerBroker = Broker.builder().credit(32500).build();
+		buyerBroker = Broker.builder().credit(0).build();
 		sellerShareholder = Shareholder.builder().build();
 		buyerShareholder = Shareholder.builder().build();
 		sellerShareholder.incPosition(security, 85);
